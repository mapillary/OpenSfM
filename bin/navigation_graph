#!/usr/bin/env python

import os.path, sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import argparse
import time
import numpy as np
import scipy.spatial.distance as dist
import networkx as nx
import cv2

from opensfm import dataset, reconstruction


def vector2_angle(x1, y1, x2, y2):
    """ Calculates the angle between two vectors on the plane.

    :param x1: The x coordinate for the first vector
    :param y1: The y coordinate for the first vector
    :param x2: The x coordinate for the second vector
    :param y2: The y coordinate for the second vector
    :return: The angle between the vectors
    """

    angle = np.arctan2(y1, x1) - np.arctan2(y2, x2)
    if angle > np.pi:
        return angle - 2 * np.pi
    elif angle < -np.pi:
        return angle + 2 * np.pi
    else:
        return angle


def angle_diff(a1, a2):
    """ Calculates the difference between two angles.

    :param a1: Array of angles
    :param a2: The angle to subtract
    :return: The difference between the angles
    """

    angles = a1 - a2

    angles[angles > np.pi] -= 2 * np.pi
    angles[angles < -np.pi] += 2 * np.pi

    return angles


def get_vertical_angles(V):
    """ Calculates the angle between vectors and the XY-plane.
    :param V: Array of 3-dimensional vectors.
    :return: The angle between the vectors and the XY-plane in radians.
    """
    return [get_vertical_angle(v) for v in V]


def get_vertical_angle(v):
    """ Calculates the angle between a vector and the XY-plane.
    :param v: A 3-dimensional vector.
    :return: The angle between the vector and the XY-plane in radians.
    """
    xy_plane_normal = np.array([0, 0, 1], np.float64)
    vertical_dir_angle = np.arcsin(np.dot(xy_plane_normal, v) / np.linalg.norm(v))

    return vertical_dir_angle


def get_positions_indices(min_distance, max_distance, distances):
    """ Retrieves the indices for the positions within a distance from the position in the
        interval between the minimum distance and the maximum distance.
    :param min_distance: Float specifying the minimum distance to the position.
    :param max_distance: Float specifying the maximum distance to the position.
    :param distances: The distances for the other positions to the position.
    :return: The indices of the positions within the interval [min_distance, max_distance].
    """
    return np.where((min_distance < distances) & (distances < max_distance))[0]


def get_direction_changes(direction, directions):
    """ Calculates the direction change parallel to the XY-plane between the direction and the other directions.
    :param direction: The direction.
    :param directions: The other directions.
    :returns The direction changes parallel to the XY-plane in radians.
    """
    direction_changes = np.array(
        [vector2_angle(direction[0], direction[1], other_direction[0], other_direction[1])
            for other_direction in directions],
        np.float64)

    return direction_changes


def get_vertical_direction_diffs(direction, directions):
    """ Calculates the vertical direction differences between the direction and the other directions.
    :param direction: The direction.
    :param directions: The other directions.
    :returns The direction changes perpendicular to the XY-plane in radians.
    """
    vertical_dir_angle = get_vertical_angle(direction)
    vertical_dir_angles = get_vertical_angles(directions)
    vertical_dir_diffs = angle_diff(vertical_dir_angles, vertical_dir_angle)

    return vertical_dir_diffs


def get_rotations(R, Rs):
    """ Calculates the rotation angle between a rotation matrix and a list of other rotation matrices.
    :param R: Rotation matrix
    :param Rs: Other rotation matrices.
    :return: The angle theta of the axis-angle representation of the rotation between the matrices.
    """
    theta = []
    RT = R.T

    for Ri in Rs:
        R_between = np.dot(RT, Ri)
        r_between, J = cv2.Rodrigues(R_between)
        theta.append(np.linalg.norm(r_between))

    return np.array(theta)


def get_direction_turns_and_motion_angles(
        min_distance,
        max_distance,
        preferred_distance,
        distances,
        position,
        direction,
        rotation_matrix,
        positions,
        directions,
        rotation_matrices):
    """ Retrieves the indices for the positions within a distance from the position in the
        interval between the minimum distance and the maximum distance.
        Also calculates the direction change and the difference in motion with respect to the direction for
        the retrieved positions.

    :param min_distance: Float specifying the minimum distance to the position.
    :param max_distance: Float specifying the maximum distance to the position.
    :param preferred_distance: Float specifying the preferred distance to the position.
    :param distances: The distances for the other positions to the position.
    :param position: The position.
    :param direction: The direction for the position.
    :param rotation_matrix: The rotation matrix.
    :param positions: All positions.
    :param directions: All directions.
    :param rotation_matrices: The rotation matrices.
    :return: The indices of the positions in the specified interval. The direction turns in radians in the plane and the
             motion turns in radians in the plane with respect to the direction. The vertical direction and motion
             changes. The rotations.
    """

    # Order positions within interval according to shortest distance
    position_indices = get_positions_indices(min_distance, max_distance, distances)
    preferred_distances = np.abs(distances[position_indices] - preferred_distance)
    ordered_indices = position_indices[np.argsort(preferred_distances)]

    motions = positions[ordered_indices] - position
    motion_angles = get_direction_changes(direction, motions)
    direction_turns = get_direction_changes(direction, directions[ordered_indices])
    vertical_dir_diffs = get_vertical_direction_diffs(direction, directions[ordered_indices])
    vertical_motion_diffs = get_vertical_direction_diffs(direction, motions)
    rotations = get_rotations(rotation_matrix, rotation_matrices[ordered_indices])

    return ordered_indices, direction_turns, motion_angles, vertical_dir_diffs, vertical_motion_diffs, rotations


def create_optical_center_graph(reconstructions, config):

    optical_centers = []
    viewing_directions = []
    rotation_matrices = []
    shot_ids = []

    for r in reconstructions:
        for shot_id in r['shots'].keys():
            shot = r['shots'][shot_id]
            optical_centers.append(reconstruction.optical_center(shot))
            viewing_directions.append(reconstruction.viewing_direction(shot))
            rotation_matrices.append(cv2.Rodrigues(np.array(shot['rotation'], dtype=float))[0])
            shot_ids.append(shot_id)

    optical_centers = np.vstack(optical_centers)
    viewing_directions = np.vstack(viewing_directions)
    rotation_matrices = np.array(rotation_matrices)

    D = dist.squareform(dist.pdist(optical_centers))

    min_distance = config.get('nav_min_distance', 0.01)
    step_pref_distance = config.get('nav_step_pref_distance', 0)

    step_max_distance = config.get('nav_step_max_distance', 20)
    step_forward_viewing_threshold = config.get('nav_step_forward_view_threshold', 0.25)
    step_viewing_threshold = config.get('nav_step_view_threshold', 0.5)
    step_drift_threshold = config.get('nav_step_drift_threshold', 0.5)

    turn_max_distance = config.get('nav_turn_max_distance', 15)
    turn_viewing_threshold = config.get('nav_turn_view_threshold', 0.7)

    direction = 'direction'
    viewing = 'viewing'
    drift = 'drift'

    steps = {
        'step_forward': {direction: 0, viewing: step_forward_viewing_threshold, drift: step_drift_threshold},
        'step_backward': {direction: np.pi, viewing: 2 * step_viewing_threshold, drift: step_drift_threshold},
        'step_left': {direction: -np.pi / 2, viewing: 2 * step_viewing_threshold, drift: step_drift_threshold},
        'step_right': {direction: np.pi / 2, viewing: 2 * step_viewing_threshold, drift: step_drift_threshold}
    }

    turns = {
        'turn_left': {direction: -np.pi / 2, viewing: turn_viewing_threshold},
        'turn_right': {direction: np.pi / 2, viewing: turn_viewing_threshold},
        'turn_u': {direction: np.pi, viewing: turn_viewing_threshold}
    }

    graph = nx.DiGraph()

    for i in range(0, D.shape[0]):

        distances = D[i, :]
        oc = optical_centers[i]
        vd = viewing_directions[i]
        rm = rotation_matrices[i]

        position_indices = get_positions_indices(min_distance, np.max([step_max_distance, turn_max_distance]), distances)

        dists = distances[position_indices]
        distances_to_pref = np.abs(dists - step_pref_distance)

        motions = optical_centers[position_indices] - oc
        motion_angles = get_direction_changes(vd, motions)
        direction_turns = get_direction_changes(vd, viewing_directions[position_indices])
        vertical_dir_diffs = get_vertical_direction_diffs(vd, viewing_directions[position_indices])
        vertical_motion_diffs = get_vertical_direction_diffs(vd, motions)
        rotations = get_rotations(rm, rotation_matrices[position_indices])

        for key in steps:
            step = steps[key]
            motion_drift = angle_diff(motion_angles, step[direction])
            motion_drift = np.max(np.vstack((np.abs(motion_drift - direction_turns), np.abs(motion_drift))), 0)

            motion_diffs = np.sqrt(np.square(motion_angles) + np.square(vertical_motion_diffs))
            penalty = distances_to_pref + 16 * rotations + 8 * motion_diffs
            ordered_indices = np.argsort(penalty)

            step_indices = np.where((dists < step_max_distance)
                                    & (motion_drift < step[drift])
                                    & (np.abs(direction_turns) < step[viewing])
                                    & (np.abs(vertical_motion_diffs) < 0.5)
                                    & (np.abs(vertical_dir_diffs) < 0.5)
                                    & (rotations < 0.5))[0]

            step_indices = ordered_indices[np.in1d(ordered_indices, step_indices)]

            if len(step_indices) > 0:
                step_index = position_indices[step_indices[0]]
                graph.add_edge(shot_ids[i], shot_ids[step_index], weight=distances[step_index], direction=key)

        ordered_indices, viewing_turns, motion_angles, vertical_dir_diffs, vertical_motion_diffs, rotations = \
            get_direction_turns_and_motion_angles(
                min_distance,
                turn_max_distance,
                0,
                distances,
                oc,
                vd,
                rm,
                optical_centers,
                viewing_directions,
                rotation_matrices
        )

        for key in turns:
            turn = turns[key]
            viewing_diff = np.abs(angle_diff(viewing_turns, turn[direction]))
            turn_indices = np.where((viewing_diff < turn[viewing])
                                    & (np.abs(vertical_motion_diffs) < 0.5)
                                    & (np.abs(vertical_dir_diffs) < 0.5))[0]

            if len(turn_indices) > 0:
                turn_index = ordered_indices[turn_indices[0]]
                graph.add_edge(shot_ids[i], shot_ids[turn_index], weight=distances[turn_index], direction=key)

    return graph


if __name__ == "__main__":
    start = time.time()
    parser = argparse.ArgumentParser(description='Compute navigation graph from reconstruction')
    parser.add_argument('dataset',
                        help='path to the dataset to be processed')
    args = parser.parse_args()

    data = dataset.DataSet(args.dataset)
    recs = data.load_reconstruction()
    navigation_graphs = []

    rec_graph = create_optical_center_graph(recs, data.config)
    navigation_graph = {
        'edges': {},
        'nodes': list(rec_graph.node)
    }

    for edge in rec_graph.edge:
        navigation_graph['edges'][edge] = rec_graph.edge[edge]

    navigation_graphs.append(navigation_graph)

    data.save_navigation_graph(navigation_graphs)

    end = time.time()
    with open(data.profile_log(), 'a') as fout:
        fout.write('Navigation graphs: {0}\n'.format(end - start))


