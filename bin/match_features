#!/usr/bin/env python
import os.path, sys
import time
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import numpy as np
import cv2
from itertools import combinations
import argparse
from opensfm import dataset
from opensfm import features
from opensfm import geo


parser = argparse.ArgumentParser(description='Match features between all image pairs.')
parser.add_argument('dataset',
                    help='path to the dataset to be processed')
args = parser.parse_args()


data = dataset.DataSet(args.dataset)
images = data.images()

print 'Loading features, indexes and exif data'
p, f = {}, {}
index = {}
preemptive_ids = {}
exifs = {}
print 'loading keypoints for {0} images'.format(len(images))
for image in images:
    sys.stdout.write('.')
    sys.stdout.flush()
    p[image], f[image] = features.read_feature(data.feature_file(image))
    index[image] = cv2.flann_Index()
    index[image].load(f[image], data.feature_index_file(image))
    sz = p[image][:,2]
    order = np.argsort(sz)
    preemptive_ids[image] = order[-data.config.get('preemptive_max', 200):]
    exifs[image] = data.exif_data(image)
print


def match(imagepair):
    im1, im2 = imagepair
    print 'Matching image', im1, 'with image', im2

    matching_gps_distance = data.config.get('matching_gps_distance', 0)
    preemptive_matching_gps_distance = data.config.get('preemptive_matching_gps_distance', 300)
    robust_matching_min_match = data.config.get('robust_matching_min_match', 20)
    preemptive_threshold = data.config.get('preemptive_threshold', 1)

    # gps distance
    distance = 0
    if im1 in exifs and im2 in exifs:
        gps1 = exifs[im1].get('gps',{})
        gps2 = exifs[im2].get('gps',{})
        if gps1 and gps2:
            lon1, lat1 = gps1['longitude'], gps1['latitude']
            lon2, lat2 = gps2['longitude'], gps2['latitude']
            distance = geo.gps_distance([lon1,lat1], [lon2, lat2])

    # preemptive matching
    if distance < preemptive_matching_gps_distance:
        t = time.time()

        matches_pre = features.match_lowe_bf(f[im1][preemptive_ids[im1],:],
                                             f[im2][preemptive_ids[im2],:],
                                             data.config)
        num_matches_pre = len(matches_pre)
        print "Preemptive matching {0}, time : {1}".format(num_matches_pre, time.time()-t)
    else:
        num_matches_pre = 0

    if num_matches_pre >= preemptive_threshold:
        t = time.time()
        matches = features.match_symmetric(f[im1], index[im1], f[im2], index[im2], data.config)
        print 'flann matching time : ', time.time() - t

        if len(matches) < robust_matching_min_match:
            print "0 / {0} matches found".format(len(matches))
        else:
            rmatches = features.robust_match(p[im1], p[im2], matches, data.config)
            if len(rmatches) >= robust_matching_min_match:
                np.savetxt(data.robust_matches_file(im1, im2), rmatches, "%d")
            print "{0} / {1} matches found".format(len(rmatches), len(matches))
    else:
        print "Too few preemptive matches / {0} matches found".format(num_matches_pre)

from multiprocessing import Pool
start = time.time()
p = Pool(data.config['processes'])
p.map(match, combinations(images, 2))
end = time.time()
with open(data.profile_log(), 'a') as fout:
    fout.write('match_features: {0}\n'.format(end - start))
