#!/usr/bin/env python

import argparse
import matplotlib.pyplot as pl
import numpy as np
import cv2

from opensfm import dataset
from opensfm import features
from opensfm import matching
from opensfm import io
from opensfm import csfm
import opensfm.reconstruction as reconstruct


def show_images(plot, im1, im2):
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    image = np.zeros((max(h1, h2), w1+w2, 3), dtype=im1.dtype)
    image[0:h1, 0:w1, :] = im1
    image[0:h2, w1:(w1+w2), :] = im2
    plot.imshow(image)


def plot_points(plot, im1, p1, point_format1='ob', im2=None, p2=None, point_format2='ob'):
    h1, w1, c = im1.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    plot.plot(p1d[:, 0], p1d[:, 1], point_format1)

    if im2 is None or p2 is None:
        return

    h2, w2, c = im2.shape
    p2d = features.denormalized_image_coordinates(p2, w2, h2)

    plot.plot(p2d[:, 0] + w1, p2d[:, 1], point_format2)


def plot_matches(plot, im1, im2, p1, p2, line_format='c', point_format='ob'):
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    p2d = features.denormalized_image_coordinates(p2, w2, h2)
    for a, b in zip(p1d, p2d):
        plot.plot([a[0], b[0] + w1], [a[1], b[1]], line_format)

    plot_points(plot, im1, p1, point_format, im2, p2, point_format)


def create_subplot(figure, rows, columns, index, title, width):
    subplot = figure.add_subplot(rows, columns, index)
    subplot.axis('off')
    pl.xlim(0, width)
    subplot.text(0.5, 0.9,
                 title,
                 horizontalalignment='center',
                 fontsize=12,
                 transform=subplot.transAxes)

    return subplot


def plot_points_sub(figure, rows, columns, index, title, im1, im2, p1, p2, point_format1, point_format2):
    subplot = create_subplot(figure, rows, columns, index, title, im1.shape[1] + im2.shape[1])

    show_images(subplot, im1, im2)
    plot_points(subplot, im1, p1, point_format1, im2, p2, point_format2)

    return subplot


def plot_matches_sub(figure, rows, columns, index, title, im1, im2, p1, p2, line_format, point_format):
    subplot = create_subplot(figure, rows, columns, index, title, im1.shape[1] + im2.shape[1])

    show_images(subplot, im1, im2)
    plot_matches(subplot, im1, im2, p1, p2, line_format, point_format)

    return subplot


def reproject_tracks(im, tracks, reconstruction):
    p = []
    for track in tracks:
        shot = reconstruction['shots'][im]
        camera = reconstruction['cameras'][shot['camera']]
        point = reconstruction['points'][str(track)]

        p.append(reconstruct.reproject(camera, shot, point))

    return np.array(p)


def find_reconstruction(images, data):
    reconstructions = data.load_reconstruction()
    reconstruction = None

    for r in reconstructions:
        found = True
        for im in images:
            if im not in r['shots']:
                found = False
                break

        if found:
            reconstruction = r
            break

    return reconstruction


def reconstruction_tracks(tracks, reconstruction):
    r_tracks = []
    for track in tracks:
        if str(track[0]) in reconstruction['points']:
            r_tracks.append(track)

    return np.array(r_tracks)


def display_figure(figure, save_figs, data=None, file_name=''):
    figure.subplots_adjust(left=0.01, bottom=0, right=0.99, top=0.97, wspace=0.04, hspace=0)

    if save_figs:
        p = data.data_path + '/plot_inliers'
        io.mkdir_p(p)
        figure.savefig(p + '/' + file_name, dpi=100)
        pl.close()
    else:
        pl.show()


def load_points(im, data):
    p, f, c = data.load_features(im)
    return np.array(p[:, :2], np.float64)


def create_matches_figure(im1, im2, data, save_figs=False):
    fig = pl.figure(figsize=(24, 12))
    fig.suptitle('Matches ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2),
                 fontsize=14, fontweight='bold')

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    # Calculate symmetric matches and plot.
    p1, f1, c1 = data.load_features(im1)
    i1 = data.load_feature_index(im1, f1)

    p2, f2, c2 = data.load_features(im2)
    i2 = data.load_feature_index(im2, f2)

    symmetric_matches = matching.match_symmetric(f1, i1, f2, i2, data.config)

    if symmetric_matches.shape[0] < 8:
        print 'Not enough matches for eight point algorithm: ' + str(symmetric_matches.shape[0])
        return

    features_title = 'Features: {0} - {1}, {2} - {3}'.format(im1, p1.shape[0], im2, p2.shape[0])
    plot_points_sub(fig, 2, 2, 1, features_title, im1_array, im2_array, p1, p2, 'ob', 'om')

    s_matches1 = p1[symmetric_matches[:, 0]]
    s_matches2 = p2[symmetric_matches[:, 1]]

    plot_matches_sub(fig, 2, 2, 3,
                     'Symmetric matches: {0}'.format(symmetric_matches.shape[0]),
                     im1_array, im2_array,
                     s_matches1, s_matches2,
                     'c', 'ob')

    # Calculate robust matches and plot inliers.
    robust_matches = matching.robust_match(p1, p2, symmetric_matches, data.config)

    r_matches1 = p1[robust_matches[:, 0]]
    r_matches2 = p2[robust_matches[:, 1]]

    threshold = data.config.get('robust_matching_threshold', 0.006)
    plot_matches_sub(fig, 2, 2, 2,
                     'Robust matching inliers (RANSAC 8 point algorithm): {0}. Threshold: {1:.4f}'.format(
                         robust_matches.shape[0], threshold),
                     im1_array, im2_array,
                     r_matches1, r_matches2,
                     'g', 'oy')

    # Retrieve and plot robust match outliers.
    outliers = np.empty((0, 2), int)
    for match in symmetric_matches:

        found = False
        for robust_match in robust_matches:
            if np.array_equal(match, robust_match):
                found = True
                break

        if not found:
            outliers = np.vstack((outliers, match))

    outliers1 = p1[outliers[:, 0]]
    outliers2 = p2[outliers[:, 1]]

    plot_matches_sub(fig, 2, 2, 4,
                     'Robust matching outliers: {0}. Threshold: {1:.4f}'.format(outliers.shape[0], threshold),
                     im1_array, im2_array,
                     outliers1, outliers2,
                     'r', 'om')

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_matches.jpg'.format(im1, im2, data.feature_type()))


def create_tracks_figure(im1, im2, data, save_figs=False):
    fig = pl.figure(figsize=(24, 12))
    fig.suptitle('Tracks ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2),
                 fontsize=14, fontweight='bold')

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    p1 = load_points(im1, data)
    p2 = load_points(im2, data)

    # Retrieve tracks and robust matches from file and plot tracks corresponding to
    # robust matches and tracks not corresponding to robust matches in different colors.
    robust_matches = data.find_matches(im1, im2)
    if not len(robust_matches):
        robust_matches = np.empty((0, 2), int)

    graph = data.load_tracks_graph()
    t1, t2 = graph[im1], graph[im2]

    track_matches = []
    for track in t1:
        if track in t2:
            track_matches.append(np.array([t1[track]['feature_id'], t2[track]['feature_id'], int(track)]))

    track_matches = np.array(track_matches)

    if track_matches.shape[0] < 5:
        print 'Not enough tracks for five point algorithm: ' + str(track_matches.shape[0])
        return

    track_points1 = p1[track_matches[:, 0]]
    track_points2 = p2[track_matches[:, 1]]

    non_robust_tracks = np.empty((0, 3), int)
    for match in track_matches:

        found = False
        for robust_match in robust_matches:
            if np.array_equal(match[:2], robust_match):
                found = True
                break

        if not found:
            non_robust_tracks = np.vstack((non_robust_tracks, match))

    non_robust_tracks1 = p1[non_robust_tracks[:, 0]]
    non_robust_tracks2 = p2[non_robust_tracks[:, 1]]

    tracks_title = 'Common tracks: {0}. Robust match tracks: {1} / {2}. Non robust match tracks: {3}'.format(
        track_matches.shape[0],
        track_matches.shape[0] - non_robust_tracks.shape[0],
        robust_matches.shape[0],
        non_robust_tracks.shape[0])

    tracks_subplot = plot_matches_sub(
        fig, 2, 2, 1, tracks_title, im1_array, im2_array, track_points1, track_points2, 'c', 'ob')
    plot_matches(tracks_subplot, im1_array, im2_array, non_robust_tracks1, non_robust_tracks2, 'g', 'oy')

    # Plot inliers and outliers of the tracks from OpenCV find homography.
    threshold_h = data.config.get('homography_threshold', 0.004)
    H, inliers_h = cv2.findHomography(track_points1, track_points2, cv2.RANSAC, threshold_h)

    inliers_h = np.array(np.squeeze(inliers_h), np.bool)

    inliers_h1 = track_points1[inliers_h, :]
    inliers_h2 = track_points2[inliers_h, :]

    outliers_h1 = track_points1[~inliers_h, :]
    outliers_h2 = track_points2[~inliers_h, :]

    h_title = 'OpenCV find homography inliers: {0}. Outliers: {1}. Outlier ratio: {2:.3f}. Threshold: {3:.4f}'.format(
        inliers_h.sum(), (~inliers_h).sum(), float((~inliers_h).sum()) / track_matches.shape[0], threshold_h)

    h_subplot = plot_matches_sub(fig, 2, 2, 3, h_title, im1_array, im2_array, outliers_h1, outliers_h2, 'r', 'om')
    plot_matches(h_subplot, im1_array, im2_array, inliers_h1, inliers_h2, 'c', 'ob')

    # Plot inliers and outliers of the tracks from csfm two view reconstruction.
    f1 = data.load_exif(im1)['focal_prior']
    f2 = data.load_exif(im2)['focal_prior']

    threshold_t = data.config.get('five_point_algo_threshold', 0.006)
    R, t, cov, inliers_t = csfm.two_view_reconstruction(track_points1, track_points2, f1, f2, threshold_t)

    inliers_t1 = track_points1[inliers_t, :]
    inliers_t2 = track_points2[inliers_t, :]

    outliers_t = np.ones(track_points1.shape[0], dtype=bool)
    outliers_t[inliers_t] = False
    outliers_t1 = track_points1[outliers_t, :]
    outliers_t2 = track_points2[outliers_t, :]

    t_title = 'CSfM two view reconstruction inliers: {0}. Outliers: {1}. Threshold: {2:.4f}'.format(
        len(inliers_t), outliers_t.sum(), threshold_t)

    t_subplot = plot_matches_sub(fig, 2, 2, 2, t_title, im1_array, im2_array, inliers_t1, inliers_t2, 'c', 'ob')
    plot_matches(t_subplot, im1_array, im2_array, outliers_t1, outliers_t2, 'r', 'om')

    # Plot successfully reconstructed and failed 3D points
    reconstruction = reconstruct.bootstrap_reconstruction(data, graph, im1, im2)

    if reconstruction:
        robust_rec_tracks = np.empty((0, 3), int)
        non_robust_rec_tracks = np.empty((0, 3), int)
        for track in reconstruction['points']:
            track = int(track)
            if track in non_robust_tracks[:, 2]:
                non_robust_track = np.squeeze(np.array(non_robust_tracks[non_robust_tracks[:, 2] == track]))
                non_robust_rec_tracks = np.vstack((non_robust_rec_tracks, non_robust_track))
            else:
                robust_track = np.squeeze(np.array(track_matches[track_matches[:, 2] == track]))
                robust_rec_tracks = np.vstack((robust_rec_tracks, robust_track))

        failed_rec_tracks = np.empty((0, 3), int)
        for track in track_matches:
            if not str(track[2]) in reconstruction['points']:
                failed_rec_tracks = np.vstack((failed_rec_tracks, track))

        robust_rec_points1 = p1[robust_rec_tracks[:, 0]]
        robust_rec_points2 = p2[robust_rec_tracks[:, 1]]

        non_robust_rec_points1 = p1[non_robust_rec_tracks[:, 0]]
        non_robust_rec_points2 = p2[non_robust_rec_tracks[:, 1]]

        failed_rec_points1 = p1[failed_rec_tracks[:, 0]]
        failed_rec_points2 = p2[failed_rec_tracks[:, 1]]

        rec_title = \
            'Reconstructed 3D points: {0}. Robust {1}. Non robust: {2}. Failed: {3}. '.format(
                len(reconstruction['points']),
                robust_rec_tracks.shape[0],
                non_robust_rec_tracks.shape[0],
                failed_rec_tracks.shape[0]) + \
            'Triangulation threshold: {0:.4f}. Min ray angle: {1}.'.format(
                data.config.get('triangulation_threshold', 0.004),
                data.config.get('triangulation_min_ray_angle', 2.0))

        rec_plot = plot_matches_sub(
            fig, 2, 2, 4, rec_title, im1_array, im2_array, robust_rec_points1, robust_rec_points2, 'c', 'ob')
        plot_matches(rec_plot, im1_array, im2_array, non_robust_rec_points1, non_robust_rec_points2, 'g', 'oy')
        plot_matches(rec_plot, im1_array, im2_array, failed_rec_points1, failed_rec_points2, 'r', 'om')
    else:
        failed_title = \
            'Reconstruction failed. Less than {0} points. Triangulation threshold: {1:.4f}. Min ray angle: {2}. '.format(
                data.config.get('five_point_algo_min_inliers', 50),
                data.config.get('triangulation_threshold', 0.004),
                data.config.get('triangulation_min_ray_angle', 2.0))
        create_subplot(fig, 2, 2, 4, failed_title, 100)

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_tracks.jpg'.format(im1, im2, data.feature_type()))


def create_reconstruction_figure(im1, im2, data, save_figs=False):
    fig = pl.figure(figsize=(18, 18))
    fig.suptitle('Reconstruction ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2),
                 fontsize=18, fontweight='bold')

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    p1 = load_points(im1, data)
    p2 = load_points(im2, data)

    graph = data.load_tracks_graph()
    t1, t2 = graph[im1], graph[im2]

    track_matches = []
    for track in t1:
        if track in t2:
            track_matches.append(np.array([int(track), t1[track]['feature_id'], t2[track]['feature_id']]))

    track_matches = np.array(track_matches)

    if track_matches.shape[0] < 1:
        print 'No tracks to plot.'
        return

    track_points1 = p1[track_matches[:, 1]]
    track_points2 = p2[track_matches[:, 2]]

    reconstruction = find_reconstruction([im1, im2], data)
    if reconstruction is None:
        print '{0} and {1} does not exist in a common reconstruction.'.format(im1, im2)

    rec_tracks = reconstruction_tracks(track_matches, reconstruction)
    rec_track_points1 = p1[rec_tracks[:, 1]]
    rec_track_points2 = p2[rec_tracks[:, 2]]

    title = 'Common tracks: {0}. Reconstructed points: {1}. Triangulation and reprojection error removals: {2}'.format(
        track_matches.shape[0], rec_tracks.shape[0], track_matches.shape[0] - rec_tracks.shape[0])

    t_subplot = plot_matches_sub(fig, 2, 1, 1, title, im1_array, im2_array, track_points1, track_points2, 'r', 'om')
    plot_matches(t_subplot, im1_array, im2_array, rec_track_points1, rec_track_points2, 'c', 'ob')

    rp1 = reproject_tracks(im1, rec_tracks[:, 0], reconstruction)
    rp2 = reproject_tracks(im2, rec_tracks[:, 0], reconstruction)

    title = 'Common tracks: {0}. Reconstructed points: {1}. Triangulation and reprojection error removals: {2}'.format(
        track_matches.shape[0], rec_tracks.shape[0], track_matches.shape[0] - rec_tracks.shape[0])

    rec_plot = plot_points_sub(fig, 2, 1, 2, title, im1_array, im2_array, track_points1, track_points2, 'or', 'or')
    plot_points(rec_plot, im1_array, rec_track_points1, 'ob', im2_array, rec_track_points2, 'ob')
    plot_points(rec_plot, im1_array, rp1, '+w', im2_array, rp2, '+w')

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_reconstruction.jpg'.format(im1, im2, data.feature_type()))


def create_complete_reconstruction_figure(im, data, save_figs=False):
    fig = pl.figure(figsize=(12, 9))
    fig.suptitle('Reprojected reconstructed 3D points ({0}): {1}'.format(data.feature_type().upper(), im),
                 fontsize=14, fontweight='bold')

    reconstruction = find_reconstruction([im], data)
    if reconstruction is None:
        print '{0} does not exist in a reconstruction.'.format(im)

    im_array = data.image_as_array(im)
    p = load_points(im, data)

    graph = data.load_tracks_graph()
    im_tracks = graph[im]

    tracks = []
    for track in im_tracks:
        tracks.append(np.array([int(track), im_tracks[track]['feature_id']]))

    tracks = np.array(tracks)
    track_points = p[tracks[:, 1]]

    rec_tracks = reconstruction_tracks(tracks, reconstruction)
    rec_track_points = p[rec_tracks[:, 1]]

    rp = reproject_tracks(im, rec_tracks[:, 0], reconstruction)

    title = 'Tracks: {0}. Reconstructed points: {1}. Triangulation and reprojection error removals: {2}'.format(
        tracks.shape[0], rec_tracks.shape[0], tracks.shape[0] - rec_tracks.shape[0])
    rec_plot = create_subplot(fig, 1, 1, 1, title, im_array.shape[1])
    rec_plot.imshow(im_array)
    plot_points(rec_plot, im_array, track_points, 'or')
    plot_points(rec_plot, im_array, rec_track_points, 'ob')
    plot_points(rec_plot, im_array, rp, '+w')

    display_figure(fig, save_figs, data, '{0}_{1}_complete_rec.jpg'.format(im, data.feature_type()))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot inlier and outlier matches between images')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('image1',
                        help='name of the first image to show')
    parser.add_argument('image2',
                        help='name of the second image to show')
    parser.add_argument('--save_figs',
                        help='save figures instead of showing them',
                        action='store_true')
    parser.add_argument('--plot_all',
                        help='save figures instead of showing them',
                        action='store_true')

    args = parser.parse_args()
    data_set = dataset.DataSet(args.dataset)

    create_matches_figure(args.image1, args.image2, data_set, args.save_figs)
    create_tracks_figure(args.image1, args.image2, data_set, args.save_figs)
    create_reconstruction_figure(args.image1, args.image2, data_set, args.save_figs)

    if args.plot_all:
        create_complete_reconstruction_figure(args.image1, data_set, args.save_figs)
        create_complete_reconstruction_figure(args.image2, data_set, args.save_figs)
