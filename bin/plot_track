#!/usr/bin/env python

import argparse
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.tri as mtri
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

from opensfm import dataset
from opensfm import multiview
import opensfm.reconstruction as reconstruct


def plot_point(plot, x, color, size=11):
    """ Plots a point.

    :param plot: The plot.
    :param x: The point.
    :param color: The color of the point.
    :param size: The size of the point.
    """

    plot.scatter(x[0], x[1], x[2], c=color, s=size)


def plot_ray(plot, p, d, l, color, name=None):
    """ Plots a ray from a point of length l in direction d.

    :param plot: The plot.
    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the ray.
    :param name: The name of the ray.
    :param color: The color of the ray.
    """

    points = line_points(p, d, l)
    plot.plot(points[0], points[1], points[2], label=name, c=color)


def plot_plane(plot, c):
    """ Plots a plane based on the defined corners.

    :param plot: The plot.
    :param c: The corners.
    """

    triangles = mtri.Triangulation(c[0, :], c[1, :])
    plot.plot_trisurf(triangles, c[2, :], color='b', alpha=0.2, linewidth=0.2)


def line_points(p, d, l):
    """ Calculates the start and end point for a line.

    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the line.
    :return: Array of coordinates for the line.
    """

    return np.add(
        np.multiply(np.resize(np.linspace(0, l, 2), (1, 2)), np.resize(d, (d.shape[0], 1))),
        np.resize(p, (p.shape[0], 1)))


def image_plane_corners(oc, KR_inv, width, height):
    """ Calculates corners of an image plane.

    :param oc: The optical center.
    :param KR_inv: The inverse of the 3 x 3 matrix of the first three columns of the camera matrix P.
    :param width: The width of the camera.
    :param height: The height of the camera.
    :return: Array of coordinates for the coordinates.
    """
    max_dim = np.max((width, height))
    dx = width / (2.0 * max_dim)
    dy = height / (2.0 * max_dim)

    corners = np.dot(KR_inv, np.array([[-dx,  dx,  dx, -dx],
                                       [-dy, -dy,  dy,  dy],
                                       [ 1,   1,   1,   1]]))

    return np.add(np.resize(oc, (3, 1)), corners)


def reconstruction_point(track, reconstruction, graph, min_ray_angle):
    point = None

    if track in reconstruction['points']:
        point = reconstruction['points'][track]['coordinates']
    else:
        reconstruct.triangulate_track(track, graph, reconstruction, {}, {}, {}, 1, min_ray_angle)
        if track in reconstruction['points']:
            point = reconstruction['points'][track]['coordinates']

    return point


def find_reconstruction(images, data):
    """ Finds the reconstruction containing the most images.

    :param images: The image names.
    :param data: The data set
    :return: The reconstruction containing the most images.
    """

    reconstructions = data.load_reconstruction()
    reconstruction = None
    rec_images = []

    contained = 0
    for r in reconstructions:
        count = 0
        ims = []
        for im in images:
            if im in r['shots']:
                ims.append(im)
                count += 1

        if count > contained:
            contained = count
            reconstruction = r
            rec_images = ims
            break

    return reconstruction, rec_images


def load_points(im, data):
    p, f, c = data.load_features(im)
    return np.array(p[:, :2], np.float64)


def plot_image_feature(plot, im, feature_id, reconstruction, point, fraction, data):
    p = load_points(im, data)
    xh = multiview.homogeneous(p[feature_id])

    shot = reconstruction['shots'][im]
    camera = reconstruction['cameras'][shot['camera']]
    P = reconstruct.projection_matrix(camera, shot)
    KR_inv = np.linalg.inv(P[:, :3])

    vs = np.dot(KR_inv, xh)

    oc = reconstruct.optical_center(reconstruction['shots'][im])
    vd = reconstruct.viewing_direction(reconstruction['shots'][im])
    cs = image_plane_corners(oc, KR_inv, camera['width'], camera['height'])

    # Plot image plane from image plane corners
    plot_plane(plot, cs)

    # Plot optical center
    plot_point(plot, oc, 'yellow')

    # Plot principal point
    principal_ray_dir = vd / np.linalg.norm(vd)
    plot_point(plot, oc + principal_ray_dir, (1., .6, .0))

    # Plot track image projection
    projection = np.dot(vs, principal_ray_dir)
    im_plane_intersect = vs / projection
    plot_point(plot, oc + im_plane_intersect, 'cyan')

    ray_length = np.linalg.norm(point - oc) + 5 if point is not None else 5

    # Plot track ray
    plot_ray(plot, oc, vs, ray_length, (.0, .9 * fraction, .2 + .7 * fraction), '{0} track ray'.format(im))

    # Plot principal ray
    plot_ray(plot, oc, vd, ray_length, 'r')

    return oc


def plot_track(track, data):
    graph = data.load_tracks_graph()

    if track not in graph:
        print 'Track {0} does not exist in the tracks graph.'.format(track)
        return

    images = graph[track]
    reconstruction, rec_images = find_reconstruction([im for im in images], data)
    if reconstruction is None:
        print 'No reconstruction for the track {0} contains any of the track images.'.format(track)
        return

    point = reconstruction_point(track, reconstruction, graph, data.config.get('triangulation_min_ray_angle', 2.0))

    fig = plt.figure(figsize=(10, 10))
    plot = fig.gca(projection='3d', aspect='equal', xlabel='X-axis', ylabel='Y-axis', zlabel='Z-axis')

    points = []
    for index, im in enumerate(rec_images):
        fraction = 1 if len(rec_images) == 1 else float(index) / (len(rec_images) - 1)
        oc = plot_image_feature(plot, im, images[im]['feature_id'], reconstruction, point, fraction, data)
        points.append(oc)

    if point is not None:
        plot_point(plot, point, 'k', 12)
        points.append(point)

    # Make sure the plot is metric.
    coord_max = np.max(points, axis=0)
    coord_min = np.min(points, axis=0)
    coord_diff = np.subtract(coord_max, coord_min)
    k = (np.max(coord_diff) - coord_diff) / 2
    min_lim = coord_min - k - 5
    max_lim = coord_max + k + 5

    plot.set_xlim(min_lim[0], max_lim[0])
    plot.set_ylim(min_lim[1], max_lim[1])
    plot.set_zlim(min_lim[2], max_lim[2])

    fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.99, wspace=0, hspace=0)

    mpl.rcParams['legend.fontsize'] = 10
    plot.legend()

    plt.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot a track in 3D')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('track',
                        help='name of the track to show', type=int)

    args = parser.parse_args()

    plot_track(str(args.track), dataset.DataSet(args.dataset))