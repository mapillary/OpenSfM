#!/usr/bin/env python

import argparse
import matplotlib as mpl
import matplotlib.pyplot as pl
import matplotlib.tri as mtri
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import itertools

from opensfm import dataset
from opensfm import features
from opensfm import io
from opensfm import multiview
import opensfm.reconstruction as reconstruct


def show_images(plot, im1, im2):
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    image = np.zeros((max(h1, h2), w1+w2, 3), dtype=im1.dtype)
    image[0:h1, 0:w1, :] = im1
    image[0:h2, w1:(w1+w2), :] = im2
    plot.imshow(image)


def plot_points(plot, im1, im2, p1, p2, point_format1='ob', point_format2='ob'):
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    p2d = features.denormalized_image_coordinates(p2, w2, h2)

    plot.plot(p1d[:, 0], p1d[:, 1], point_format1)
    plot.plot(p2d[:, 0] + w1, p2d[:, 1], point_format2)


def create_subplot(figure, rows, columns, index, title, width, height, font_size=12):
    """ Creates a subplot with the supplied width. """
    subplot = figure.add_subplot(rows, columns, index)
    subplot.axis('off')
    pl.xlim(0, width)
    pl.ylim(height, 0)
    subplot.text(0.5, 1.04,
                 title,
                 horizontalalignment='center',
                 fontsize=font_size,
                 transform=subplot.transAxes)

    return subplot


def plot_point(plot, x, color, size=11):
    """ Plots a point.

    :param plot: The plot.
    :param x: The point.
    :param color: The color of the point.
    :param size: The size of the point.
    """

    plot.scatter(x[0], x[1], x[2], c=color, s=size)


def plot_ray(plot, p, d, l, color, name=None):
    """ Plots a ray from a point of length l in direction d.

    :param plot: The plot.
    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the ray.
    :param name: The name of the ray.
    :param color: The color of the ray.
    """

    points = line_points(p, d, l)
    plot.plot(points[0], points[1], points[2], label=name, c=color)


def plot_plane(plot, c):
    """ Plots a plane based on the defined corners.

    :param plot: The plot.
    :param c: The corners.
    """

    triangles = mtri.Triangulation(c[0, :], c[1, :])
    plot.plot_trisurf(triangles, c[2, :], color='b', alpha=0.2, linewidth=0.1)


def line_points(p, d, l):
    """ Calculates the start and end point for a line.

    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the line.
    :return: Array of coordinates for the line.
    """

    return np.add(
        np.multiply(np.resize(np.linspace(0, l, 2), (1, 2)), np.resize(d, (d.shape[0], 1))),
        np.resize(p, (p.shape[0], 1)))


def image_plane_corners(oc, KR_inv, width, height):
    """ Calculates corners of an image plane.

    :param oc: The optical center.
    :param KR_inv: The inverse of the 3 x 3 matrix of the first three columns of the camera matrix P.
    :param width: The width of the camera.
    :param height: The height of the camera.
    :return: Array of coordinates for the coordinates.
    """
    max_dim = np.max((width, height))
    dx = width / (2.0 * max_dim)
    dy = height / (2.0 * max_dim)

    corners = np.dot(KR_inv, np.array([[-dx,  dx,  dx, -dx],
                                       [-dy, -dy,  dy,  dy],
                                       [ 1,   1,   1,   1]]))

    return np.add(np.resize(oc, (3, 1)), corners)


def camera_matrix(im, reconstruction):
    shot = reconstruction['shots'][im]
    camera = reconstruction['cameras'][shot['camera']]
    return reconstruct.projection_matrix(camera, shot)


def epipole(Pi, Cj):
    ei = np.dot(Pi, Cj)
    return ei / ei[2]


def fundamental_matrix(P1, P2, C1):
    P1_pinv = np.linalg.pinv(P1)

    e2 = epipole(P2, C1)
    e2_cross = np.array([[ 0,     -e2[2],   e2[1]],
                         [ e2[2],  0,      -e2[0]],
                         [-e2[1],  e2[0],   0]])

    F = np.dot(e2_cross, np.dot(P2, P1_pinv))

    return F / F[2, 2]


def epipolar_line(F, x):
    return np.dot(F, multiview.homogeneous(x))


def points_from_line_equation(l, x0=-.5, xn=.5, N=2):
    x = np.linspace(x0, xn, N)
    y = (-l[0] * x - l[2]) / l[1]

    x = np.resize(x, (x.shape[0], 1))
    y = np.resize(y, (y.shape[0], 1))

    return np.hstack((x, y))


def reconstruction_point(track, reconstruction, graph, min_ray_angle):
    point = None

    if track in reconstruction['points']:
        point = reconstruction['points'][track]['coordinates']
    else:
        reconstruct.triangulate_track(track, graph, reconstruction, {}, {}, {}, 1, min_ray_angle)
        if track in reconstruction['points']:
            point = reconstruction['points'][track]['coordinates']

    return point


def find_reconstruction(images, data):
    """ Finds the reconstruction containing the most images.

    :param images: The image names.
    :param data: The data set
    :return: The reconstruction containing the most images.
    """

    reconstructions = data.load_reconstruction()
    reconstruction = None
    rec_images = []

    contained = 0
    for r in reconstructions:
        count = 0
        ims = []
        for im in images:
            if im in r['shots']:
                ims.append(im)
                count += 1

        if count > contained:
            contained = count
            reconstruction = r
            rec_images = ims
            break

    return reconstruction, rec_images


def load_points(im, data):
    p, f, c = data.load_features(im)
    return np.array(p[:, :2], np.float64)


def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]


def plot_image_feature(plot, im, feature_id, reconstruction, point, fraction, data):
    p = load_points(im, data)
    xh = multiview.homogeneous(p[feature_id])

    shot = reconstruction['shots'][im]
    camera = reconstruction['cameras'][shot['camera']]
    P = reconstruct.projection_matrix(camera, shot)
    KR_inv = np.linalg.inv(P[:, :3])

    vs = np.dot(KR_inv, xh)

    oc = reconstruct.optical_center(shot)
    vd = reconstruct.viewing_direction(shot)
    cs = image_plane_corners(oc, KR_inv, camera['width'], camera['height'])

    # Plot image plane from image plane corners
    plot_plane(plot, cs)

    # Plot optical center
    plot_point(plot, oc, 'yellow')

    # Plot principal point
    principal_ray_dir = vd / np.linalg.norm(vd)
    plot_point(plot, oc + principal_ray_dir, (1., .6, .0))

    # Plot track image projection
    projection = np.dot(vs, principal_ray_dir)
    im_plane_intersect = vs / projection
    plot_point(plot, oc + im_plane_intersect, 'cyan')

    ray_length = np.linalg.norm(point - oc) + 5 if point is not None else 5

    # Plot track ray
    plot_ray(plot, oc, vs, ray_length, (.0, .9 * fraction, .2 + .7 * fraction), '{0} track ray'.format(im))

    # Plot principal ray
    plot_ray(plot, oc, vd, ray_length, 'r')

    return oc


def plot_track_ray(track, data):
    graph = data.load_tracks_graph()

    if track not in graph:
        print 'Track {0} does not exist in the tracks graph.'.format(track)
        return

    images = graph[track]
    reconstruction, rec_images = find_reconstruction([im for im in images], data)
    if reconstruction is None:
        print 'No reconstruction for the track {0} contains any of the track images.'.format(track)
        return

    point = reconstruction_point(track, reconstruction, graph, data.config.get('triangulation_min_ray_angle', 2.0))

    fig = pl.figure(figsize=(10, 10))
    plot = fig.gca(projection='3d', aspect='equal', xlabel='X-axis', ylabel='Y-axis', zlabel='Z-axis')

    points = []
    for index, im in enumerate(rec_images):
        fraction = 1 if len(rec_images) == 1 else float(index) / (len(rec_images) - 1)
        oc = plot_image_feature(plot, im, images[im]['feature_id'], reconstruction, point, fraction, data)
        points.append(oc)

    if point is not None:
        plot_point(plot, point, 'k', 12)
        points.append(point)

    # Make sure the plot is metric.
    coord_max = np.max(points, axis=0)
    coord_min = np.min(points, axis=0)
    coord_diff = np.subtract(coord_max, coord_min)
    k = (np.max(coord_diff) - coord_diff) / 2
    min_lim = coord_min - k - 5
    max_lim = coord_max + k + 5

    plot.set_xlim(min_lim[0], max_lim[0])
    plot.set_ylim(min_lim[1], max_lim[1])
    plot.set_zlim(min_lim[2], max_lim[2])

    fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.99, wspace=0, hspace=0)

    mpl.rcParams['legend.fontsize'] = 10
    plot.legend()

    pl.show()


def plot_epipolar_line(subplot, im1, im2, im1_array, im2_array, f1, f2, reconstruction, data):
    p1 = load_points(im1, data)
    p2 = load_points(im2, data)

    P1 = camera_matrix(im1, reconstruction)
    P2 = camera_matrix(im2, reconstruction)

    C1 = multiview.homogeneous(reconstruct.optical_center(reconstruction['shots'][im1]))
    C2 = multiview.homogeneous(reconstruct.optical_center(reconstruction['shots'][im2]))

    F = fundamental_matrix(P1, P2, C1)

    x1 = p1[f1]
    x2 = p2[f2]

    l1 = epipolar_line(F.T, x2)
    l2 = epipolar_line(F, x1)

    lp1 = points_from_line_equation(l1)
    lp2 = points_from_line_equation(l2)

    e1 = epipole(P1, C2)
    e2 = epipole(P2, C1)

    plot_points(subplot, im1_array, im2_array, np.resize(x1, (1, 2)), np.resize(x2, (1, 2)), 'oc', 'oc')
    plot_points(subplot, im1_array, im2_array, np.resize(e1[:2], (1, 2)), np.resize(e2[:2], (1, 2)), 'or', 'or')
    plot_points(subplot, im1_array, im2_array, lp1, lp2, 'r', 'r')


def plot_epipolar_lines(track, data, images=[], save_figs=False):
    graph = data.load_tracks_graph()

    if track not in graph:
        print 'Track {0} does not exist in the tracks graph.'.format(track)
        return

    track_ims = graph[track]
    reconstruction, rec_ims = find_reconstruction([im for im in track_ims], data)
    if reconstruction is None:
        print 'No reconstruction for the track {0} contains any of the track images.'.format(track)
        return

    for im in images:
        if not im in rec_ims:
            print 'Track {0} is not connected to image {1} in the reconstruction.'.format(track, im)
            return

    rec_ims = sorted(rec_ims)
    if len(images) == 1:
        comb = [(images[0], im) for im in rec_ims if im != images[0]]
    elif len(images) == 2:
        comb = [(images[0], images[1])]
    else:
        comb = list(itertools.combinations(rec_ims, 2))

    n = len(comb)

    for chunk_index, chunk in enumerate(list(chunks(comb, 4))):
        chunk_size = len(chunk)
        rows = 2 if chunk_size > 1 else 1
        cols = 2 if chunk_size > 2 else 1

        fig = pl.figure(figsize=(12 * cols, 6 * rows))
        fig.suptitle('Epipolar lines for track {0} ({1})'.format(track, data.feature_type().upper()),
                     fontsize=14, fontweight='bold')

        for index, ims in enumerate(chunk):
            im1 = ims[0]
            im2 = ims[1]

            print 'Plotting epipolar line for {0} - {1} ({2} / {3})'.format(im1, im2, chunk_index * 4 + index + 1, n)

            im1_array = data.image_as_array(im1)
            im2_array = data.image_as_array(im2)

            h1, w1, c = im1_array.shape
            h2, w2, c = im2_array.shape

            subplot = create_subplot(fig, rows, cols, index + 1, '{0} - {1}'.format(im1, im2), w1+w2, h1)
            show_images(subplot, im1_array, im2_array)

            f1 = track_ims[im1]['feature_id']
            f2 = track_ims[im2]['feature_id']

            plot_epipolar_line(subplot, im1, im2, im1_array, im2_array, f1, f2, reconstruction, data)

        fig.subplots_adjust(left=0.01, bottom=0, right=0.99, top=0.92, wspace=0.04, hspace=0.1)

        if save_figs:
            path = data.data_path + '/plot_track'
            io.mkdir_p(path)
            fig.savefig(
                path + '/' + 'track_{0}_{1}_epipolar_{2}.jpg'.format(track, data.feature_type(), chunk_index + 1),
                dpi=100)
            pl.close()
        else:
            pl.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot a track in 3D')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('track',
                        help='name of the track to plot (integer)', type=int)
    parser.add_argument('--image1',
                        help='name of image for whose combinations should be plotted for the track')
    parser.add_argument('--image2',
                        help='name of image to plot in combination with image1 (only used if image1 is specified)')
    parser.add_argument('--save_figs',
                        help='save epipolar line figures instead of showing them',
                        action='store_true')

    args = parser.parse_args()
    ds = dataset.DataSet(args.dataset)
    tr = str(args.track)

    arg_ims = []
    if args.image1:
        arg_ims.append(args.image1)
        if args.image2:
            arg_ims.append(args.image2)

    plot_epipolar_lines(tr, ds, arg_ims, args.save_figs)
    plot_track_ray(tr, ds)