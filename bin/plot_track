#!/usr/bin/env python

import argparse
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.tri as mtri
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

from opensfm import dataset
from opensfm import multiview
import opensfm.reconstruction as reconstruct


def plot_point(plot, x, color):
    plot.scatter(x[0], x[1], x[2], c=color)


def plot_ray(plot, p, d, l, name, color):
    x, y, z = get_line(p, d, l)
    plot.plot(x, y, z, label=name, c=color)


def plot_plane(plot, cor):
    triangles = mtri.Triangulation(cor[0, :], cor[1, :])
    plot.plot_trisurf(triangles, cor[2, :], color='b', alpha=0.2, linewidth=0.2)


def get_line(p, d, l):
    a = np.linspace(0, l, 100)
    x = a * d[0] + p[0]
    y = a * d[1] + p[1]
    z = a * d[2] + p[2]

    return x, y, z


def image_plane_corners(oc, KR1, width, height):
    max_dim = np.max((width, height))
    dx = width / (2.0 * max_dim)
    dy = height / (2.0 * max_dim)

    corners = np.dot(KR1, np.array([[-dx,  dx,  dx, -dx],
                                    [-dy, -dy,  dy,  dy],
                                    [ 1,   1,   1,   1]]))

    return np.add(np.resize(oc, (3, 1)), corners)


def reconstruction_point(track, reconstruction, graph, min_ray_angle):
    point = None

    if track in reconstruction['points']:
        point = reconstruction['points'][track]['coordinates']
    else:
        reconstruct.triangulate_track(track, graph, reconstruction, {}, {}, {}, 1, min_ray_angle)
        if track in reconstruction['points']:
            point = reconstruction['points'][track]['coordinates']

    return np.array(point)


def find_reconstruction(images, data):
    reconstructions = data.load_reconstruction()
    reconstruction = None

    for r in reconstructions:
        found = True
        for im in images:
            if im not in r['shots']:
                found = False
                break

        if found:
            reconstruction = r
            break

    return reconstruction


def load_track(im, track, data):
    graph = data.load_tracks_graph()
    tracks = graph[im]

    return np.array([int(track), tracks[track]['feature_id']]) if track in tracks else None


def load_points(im, data):
    p, f, c = data.load_features(im)
    return np.array(p[:, :2], np.float64)


def plot_image_track(plot, im, track, reconstruction, point, data):
    t = load_track(im, track, data)
    p = load_points(im, data)
    xh = multiview.homogeneous(p[t[1]])

    shot = reconstruction['shots'][im]
    camera = reconstruction['cameras'][shot['camera']]
    P = reconstruct.projection_matrix(camera, shot)
    KR1 = np.linalg.inv(P[:, :3])

    vs = np.dot(KR1, xh)

    oc = reconstruct.optical_center(reconstruction['shots'][im])
    vd = reconstruct.viewing_direction(reconstruction['shots'][im])
    cs = image_plane_corners(oc, KR1, camera['width'], camera['height'])

    # Plot image plane from image plane corners
    plot_plane(plot, cs)

    # Plot optical center
    plot_point(plot, oc, 'r')

    # Plot principal point
    principal_ray_dir = vd / np.linalg.norm(vd)
    plot_point(plot, oc + principal_ray_dir, 'g')

    # Plot track image projection
    projection = np.dot(vs, principal_ray_dir)
    im_plane_intersect = vs / projection
    plot_point(plot, oc + im_plane_intersect, 'c')

    ray_length = np.linalg.norm(point - oc) + 5 if point is not None else 5

    # Plot track ray
    plot_ray(plot, oc, vs, ray_length, '{0} track ray'.format(im), 'c')

    # Plot principal ray
    plot_ray(plot, oc, vd, ray_length, '{0} principal ray'.format(im), 'g')

    return oc


def plot_track(track, data):
    graph = data.load_tracks_graph()

    images = graph[track]

    reconstruction = find_reconstruction([key for key in images], data)
    if reconstruction is None:
        print 'All images for the track {0} does not exist in a single reconstruction.'.format(track)

    point = reconstruction_point(track, reconstruction, graph, data.config.get('triangulation_min_ray_angle', 2.0))

    fig = plt.figure(figsize=(10, 10))
    plot = fig.gca(projection='3d', aspect='equal', xlabel='X-axis', ylabel='Y-axis', zlabel='Z-axis')

    ocs = []
    for im in images:
        oc = plot_image_track(plot, im, track, reconstruction, point, data)
        ocs.append(oc)

    ocs = np.array(ocs)

    if point is not None:
        plot_point(plot, point, 'k')
        points = np.vstack((ocs, point))
    else:
        points = ocs

    # Make sure the plot is metric.
    coord_max = np.max(points, axis=0)
    coord_min = np.min(points, axis=0)
    coord_diff = np.subtract(coord_max, coord_min)
    k = (np.max(coord_diff) - coord_diff) / 2
    min_lim = coord_min - k - 5
    max_lim = coord_max + k + 5

    plot.set_xlim(min_lim[0], max_lim[0])
    plot.set_ylim(min_lim[1], max_lim[1])
    plot.set_zlim(min_lim[2], max_lim[2])

    fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.99, wspace=0, hspace=0)

    mpl.rcParams['legend.fontsize'] = 10
    plot.legend()

    plt.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot a track in 3D')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('track',
                        help='name of the track to show')

    args = parser.parse_args()

    plot_track(args.track, dataset.DataSet(args.dataset))