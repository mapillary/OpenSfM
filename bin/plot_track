#!/usr/bin/env python

import os.path, sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import argparse
import matplotlib as mpl
import matplotlib.pyplot as pl
import matplotlib.tri as mtri
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import itertools
import cv2

from opensfm import dataset
from opensfm import features
from opensfm import io
from opensfm import multiview
import opensfm.reconstruction as reconstruct


def show_images(plot, im1, im2):
    """ Shows the images in the supplied subplot. """
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    image = np.zeros((max(h1, h2), w1+w2, 3), dtype=im1.dtype)
    image[0:h1, 0:w1, :] = im1
    image[0:h2, w1:(w1+w2), :] = im2
    plot.imshow(image)


def plot_points(plot, im1, im2, p1, p2, point_format1='ob', point_format2='ob'):
    """ Plots the points in the supplied subplot. """
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    p2d = features.denormalized_image_coordinates(p2, w2, h2)

    plot.plot(p1d[:, 0], p1d[:, 1], point_format1)
    plot.plot(p2d[:, 0] + w1, p2d[:, 1], point_format2)


def create_subplot(figure, rows, columns, index, title, width, height, font_size=12):
    """ Creates a subplot with the supplied width. """
    subplot = figure.add_subplot(rows, columns, index)
    subplot.axis('off')
    pl.xlim(0, width)
    pl.ylim(height, 0)
    subplot.text(0.5, 1.04,
                 title,
                 horizontalalignment='center',
                 fontsize=font_size,
                 transform=subplot.transAxes)

    return subplot


def plot_point(plot, x, color, size=11):
    """ Plots a point.

    :param plot: The plot.
    :param x: The point.
    :param color: The color of the point.
    :param size: The size of the point.
    """

    plot.scatter(x[0], x[1], x[2], c=color, s=size)


def plot_ray(plot, p, d, l, color, name=None):
    """ Plots a ray from a point of length l in direction d.

    :param plot: The plot.
    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the ray.
    :param name: The name of the ray.
    :param color: The color of the ray.
    """

    points = line_points(p, d, l)
    plot.plot(points[0], points[1], points[2], label=name, c=color)


def plot_plane(plot, c):
    """ Plots a plane based on the defined corners.

    :param plot: The plot.
    :param c: The corners.
    """

    triangles = mtri.Triangulation(c[0, :], c[1, :])
    plot.plot_trisurf(triangles, c[2, :], color='b', alpha=0.1, linewidth=0., shade=False)


def plot_camera(plot, oc, c):
    """ Plots camera lines from optical center to image plane corners as well as the image plane.
    :param plot: The plot.
    :param oc: The optical center.
    :param c: The camera plane corners.
    """

    points = np.array([oc, c[:, 0], oc, c[:, 1], oc, c[:, 2], oc, c[:, 3],
                       c[:, 0], c[:, 1], c[:, 2], c[:, 3]])

    plot.plot(points[:, 0], points[:, 1], points[:, 2], c='k', linewidth=1, alpha=0.25)
    plot_plane(plot, c)


def line_points(p, d, l):
    """ Calculates the start and end point for a line.

    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the line.
    :return: Array of coordinates for the line.
    """

    return np.add(
        np.multiply(np.resize(np.linspace(0, l, 2), (1, 2)), np.resize(d, (d.shape[0], 1))),
        np.resize(p, (p.shape[0], 1)))


def image_plane_corners(oc, KR_inv, width, height):
    """ Calculates corners of an image plane.

    :param oc: The optical center.
    :param KR_inv: The inverse of the 3 x 3 matrix of the first three columns of the camera matrix P.
    :param width: The width of the camera.
    :param height: The height of the camera.
    :return: Array of coordinates for the coordinates.
    """
    max_dim = np.max((width, height))
    dx = width / (2.0 * max_dim)
    dy = height / (2.0 * max_dim)

    corners = np.dot(KR_inv, np.array([[-dx,  dx,  dx, -dx],
                                       [-dy, -dy,  dy,  dy],
                                       [ 1,   1,   1,   1]]))

    return np.add(np.resize(oc, (3, 1)), corners)


def epipole(Pi, Cj):
    """ Calculates the epipole for another camera.

    :param Pi: The camera matrix for the first camera.
    :param Cj: The camera center for the second camera.
    :return: The epipole of the second camera for the first.
    """
    ei = np.dot(Pi, Cj)

    return ei / ei[2]


def fundamental_matrix(P1, P2, C1):
    """ Calculates the fundamental matrix for two cameras.

    :param P1: The camera matrix for the first camera.
    :param P2: The camera matrix for the second camera.
    :param C1: The camera center for the first camera in homogeneous coordinates.
    :return: The fundamental matrix for the cameras.
    """
    P1_pinv = np.linalg.pinv(P1)

    e2 = epipole(P2, C1)
    e2_skew = np.array([[ 0,     -e2[2],   e2[1]],
                        [ e2[2],  0,      -e2[0]],
                        [-e2[1],  e2[0],   0]])

    F = np.dot(e2_skew, np.dot(P2, P1_pinv))

    return F


def epipolar_line(F, x):
    """ Calculates the epipolar line for a point in the other image.

    :param F: Fundamental matrix.
    :param x: Point in other image in homogeneous coordinates.
    :return: The epipolar line for the point in the other image.
    """
    return np.dot(F, x)


def line_equation_points(l, xy_min=-1., xy_max=1., n=400):
    """ Calculates points on a line.

    :param l: Line equation
    :param xy_min: Smallest value.
    :param xy_max: Largest value.
    :param n: Number of points.
    :return: An array of points that lie on the line.
    """

    # Create linear space points along axis with most slope with respect to the other.
    if np.abs(l[0]) > np.abs(l[1]):
        y = np.linspace(xy_min, xy_max, n)
        x = (-l[1] * y - l[2]) / l[0]
    else:
        x = np.linspace(xy_min, xy_max, n)
        y = (-l[0] * x - l[2]) / l[1]

    x = np.resize(x, (x.shape[0], 1))
    y = np.resize(y, (y.shape[0], 1))

    return np.hstack((x, y))


def closest_line_point(x, l):
    """ Calculates the point on the line that is closest to x.

    :param x: Point.
    :param l: Line equation.
    :return: The point on the line that is closest to x.
    """
    d = l[0]**2 + l[1]**2
    xl = (l[1] * (l[1]*x[0] - l[0]*x[1]) - l[0]*l[2]) / d
    yl = (l[0] * (l[0]*x[1] - l[1]*x[0]) - l[1]*l[2]) / d

    return np.array([xl, yl])


def distance_to_line(x, l):
    """ Calculates the shortest distance from a point to a line.

    :param x: Point.
    :param l: Line equation.
    :return: The distance from the point to the line.
    """
    d = l[0]**2 + l[1]**2

    return np.abs(np.dot(l, multiview.homogeneous(x))) / np.sqrt(d)


def approx_distance_to_curve(camera, x, l):
    """ Calculates an approximate distance from a distorted point to the epipolar curve.
        Determines the closest point on the epipolar line, distorts the input point and the
        line point and calculates the distance of the distorted points.

    :param camera: The camera
    :param x: Undistorted point.
    :param l: Undistorted line equation
    :return: Approximate distance between the distorted point and the epipolar curve.
    """
    x_line = closest_line_point(x, l)
    x_curve = np.array(reconstruct.distort(camera, x_line[0], x_line[1]))
    x_distort = np.array(reconstruct.distort(camera, x[0], x[1]))

    return np.linalg.norm(np.subtract(x_distort, x_curve))


def reconstruction_point(track, reconstruction, graph, min_ray_angle):
    """ Retrieves the 3D point from a reconstruction. If the point for the track does not exist
        in the reconstruction an attempt is made to triangulate the track.

    :param track: A track.
    :param reconstruction: A reconstruction.
    :param graph: A track graph.
    :param min_ray_angle: Minimum ray angle between track rays for a track to be triangulated.
    :return:
    """
    point = None
    result = 'rejected and failed'

    if track in reconstruction['points']:
        point = reconstruction['points'][track]['coordinates']
        result = 'reconstructed'
    else:
        reconstruct.triangulate_track(track, graph, reconstruction, {}, {}, {}, 1, min_ray_angle)
        if track in reconstruction['points']:
            point = reconstruction['points'][track]['coordinates']
            result = 'rejected and re-triangulated'

    return point, result


def find_reconstruction(images, data):
    """ Finds the reconstruction containing the most images.

    :param images: The image names.
    :param data: The data set
    :return: The reconstruction containing the most images.
    """

    reconstructions = data.load_reconstruction()
    reconstruction = None
    rec_images = []

    contained = 0
    for r in reconstructions:
        count = 0
        ims = []
        for im in images:
            if im in r['shots']:
                ims.append(im)
                count += 1

        if count > contained:
            contained = count
            reconstruction = r
            rec_images = ims
            break

    return reconstruction, rec_images


def distort_points(camera, x):
    """ Distorts a points using the distortion coefficients of the camera.
    :param camera: The camera.
    :param x: The points.
    :return: Array of distorted points.
    """
    result = []

    for point in x:
        x_distort, y_distort = reconstruct.distort(camera, point[0], point[1])
        result.append(np.array([x_distort, y_distort]))

    return np.array(result)


def undistort_image(im_array, camera):
    """ Undistorts an image using the camera properties.
    :param im_array: The image array.
    :param camera: The camera.
    :return: An image with the undistorted pixels.
    """
    d = np.array([camera['k1'], camera['k2'], 0., 0., 0.])
    f = camera['focal']
    w = camera['width']
    h = camera['height']

    s = np.max([w, h])

    K = np.array([[s*f, 0,   w/2],
                  [0,   s*f, h/2],
                  [0,   0,   1]])

    undistorted_im_array = cv2.undistort(im_array, K, d)

    return undistorted_im_array


def shot_camera(im, reconstruction):
    """ Retrieves the shot and camera for an image in a reconstruction.
    :param im: The image name.
    :param reconstruction: The reconstruction.
    :return: The shot and the camera for the image.
    """
    shot = reconstruction['shots'][im]
    camera = reconstruction['cameras'][shot['camera']]

    return shot, camera


def chunks(l, n):
    """ Separates a list in smaller chunks of items.

    :param l: List
    :param n: Number of items in each chunk
    :return: Chunks of the specified size.
    """
    for i in xrange(0, len(l), n):
        yield l[i:i+n]


def plot_image_feature(plot, im, x, reconstruction, point, fraction):
    """ Adds camera lines, image plane, principal ray and track ray to a 3D plot.

    :param plot: Subplot.
    :param im: Image name.
    :param x: Feature point coordinates.
    :param reconstruction: Reconstruction.
    :param point: Reconstructed 3D point.
    :param fraction: Fraction of plots that has been created.
    :return: The optical center of the shot for the image.
    """
    xh = multiview.homogeneous(x)

    shot, camera = shot_camera(im, reconstruction)
    P = reconstruct.projection_matrix(camera, shot)
    KR_inv = np.linalg.inv(P[:, :3])

    vs = np.dot(KR_inv, xh)

    oc = reconstruct.optical_center(shot)
    vd = reconstruct.viewing_direction(shot)
    cs = image_plane_corners(oc, KR_inv, camera['width'], camera['height'])

    # Plot camera lines and image plane
    plot_camera(plot, oc, cs)

    # Plot principal point
    principal_ray_dir = vd / np.linalg.norm(vd)
    plot_point(plot, oc + principal_ray_dir, (1., .6, .0))

    # Plot track image projection
    projection = np.dot(vs, principal_ray_dir)
    im_plane_intersect = vs / projection
    plot_point(plot, oc + im_plane_intersect, 'cyan')

    ray_length = np.linalg.norm(point - oc) + 5 if point is not None else 5

    # Plot track ray
    plot_ray(plot, oc, vs, ray_length, (.0, .9 * fraction, .2 + .7 * fraction), '{0} track ray'.format(im))

    # Plot principal ray
    plot_ray(plot, oc, vd, ray_length, 'r')

    return oc


def plot_track_rays(track, data):
    """ Plots the rays for all images connected to the track.

    :param track: The track name.
    :param data: Data set.
    """

    graph = data.load_tracks_graph()

    if track not in graph:
        print 'Track {0} does not exist in the tracks graph.'.format(track)
        return

    images = graph[track]
    reconstruction, rec_images = find_reconstruction([im for im in images], data)
    if reconstruction is None:
        print 'No reconstruction for the track {0} contains any of the track images.'.format(track)
        return

    point, res = reconstruction_point(track, reconstruction, graph, data.config.get('triangulation_min_ray_angle', 2.0))

    fig = pl.figure(figsize=(10, 10))
    title = 'Track {0} ({1}): {2}'.format(track, data.feature_type().upper(), res)
    fig.suptitle(title, fontsize=14, fontweight='bold')
    plot = fig.gca(projection='3d', aspect='equal', xlabel='X-axis', ylabel='Y-axis', zlabel='Z-axis')

    points = []
    for index, im in enumerate(rec_images):
        fraction = 1 if len(rec_images) == 1 else float(index) / (len(rec_images) - 1)
        oc = plot_image_feature(plot, im, np.array(images[im]['feature']), reconstruction, point, fraction)
        points.append(oc)

    if point is not None:
        plot_point(plot, point, 'k', 12)
        points.append(point)

    # Make sure the plot is metric.
    coord_max = np.max(points, axis=0)
    coord_min = np.min(points, axis=0)
    coord_diff = np.subtract(coord_max, coord_min)
    k = (np.max(coord_diff) - coord_diff) / 2
    min_lim = coord_min - k - 5
    max_lim = coord_max + k + 5

    plot.set_xlim(min_lim[0], max_lim[0])
    plot.set_ylim(min_lim[1], max_lim[1])
    plot.set_zlim(min_lim[2], max_lim[2])

    fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.95, wspace=0, hspace=0)

    mpl.rcParams['legend.fontsize'] = 10
    plot.legend()

    pl.show()


def plot_epipolar_geo(subplot, im1, im2, im1_array, im2_array, x1, x2, reconstruction, distort=True):
    """ Plots the epipolar lines/curves, epipoles and feature points for an image pair.

    :param subplot: Subplot.
    :param im1: Image name for first image.
    :param im2: Image name for second image.
    :param im1_array: Image array for first image.
    :param im2_array: Image array for second image.
    :param x1: Feature point for first image.
    :param x2: Feature point for second image.
    :param reconstruction: Reconstruction.
    :param distort: Bool specifying if the image should be distorted or undistorted. Default is distorted.
    :return: The distance to the epipolar line/curve for each feature point.
    """

    shot1, camera1 = shot_camera(im1, reconstruction)
    shot2, camera2 = shot_camera(im2, reconstruction)

    P1 = reconstruct.projection_matrix(camera1, shot1)
    P2 = reconstruct.projection_matrix(camera2, shot2)

    C1 = multiview.homogeneous(reconstruct.optical_center(shot1))
    C2 = multiview.homogeneous(reconstruct.optical_center(shot2))

    F = fundamental_matrix(P1, P2, C1)

    # Undistort points before calculating epipolar line.
    x1u = np.squeeze(multiview.undistort_points(camera1, np.reshape(x1, (2, 1))))
    x2u = np.squeeze(multiview.undistort_points(camera2, np.reshape(x2, (2, 1))))

    l1 = epipolar_line(F.T, multiview.homogeneous(x2u))
    l2 = epipolar_line(F, multiview.homogeneous(x1u))

    lp1 = line_equation_points(l1)
    lp2 = line_equation_points(l2)

    e1 = epipole(P1, C2)
    e2 = epipole(P2, C1)

    d1 = distance_to_line(x1u, l1)
    d2 = distance_to_line(x2u, l2)

    if distort:
        # Distort epipolar line points to transform them to epipolar curve points.
        lp1 = distort_points(camera1, lp1)
        lp2 = distort_points(camera2, lp2)

        # Distort epipole.
        e1 = np.array(reconstruct.distort(camera1, e1[0], e1[1]))
        e2 = np.array(reconstruct.distort(camera2, e2[0], e2[1]))

        # Calculate approximate distance to curve by just distorting closest line point
        d1 = approx_distance_to_curve(camera1, x1u, l1)
        d2 = approx_distance_to_curve(camera2, x2u, l2)

        # Distort feature points
        x1u = x1
        x2u = x2

    lp1 = lp1[lp1[:, 0] <= .5]
    lp2 = lp2[lp2[:, 0] >= -.5]

    plot_points(subplot, im1_array, im2_array, lp1, lp2, 'r', 'r')
    plot_points(subplot, im1_array, im2_array, np.resize(e1[:2], (1, 2)), np.resize(e2[:2], (1, 2)), 'or', 'or')
    plot_points(subplot, im1_array, im2_array, np.resize(x1u, (1, 2)), np.resize(x2u, (1, 2)), 'ob', 'ob')

    return d1, d2


def plot_reprojections(subplot, im1, im2, im1_array, im2_array, x1, x2, track, reconstruction, distort):
    """ Plots the reprojections for a track for each image.

    :param subplot: Subplot.
    :param im1: Image name for first image.
    :param im2: Image name for second image.
    :param im1_array: Image array for first image.
    :param im2_array: Image array for second image.
    :param x1: Feature point for first image.
    :param x2: Feature point for second image.
    :param track: The track name.
    :param reconstruction: The reconstruction.
    :param distort: Bool specifying if the image should be distorted or undistorted. Default is distorted.
    :return: The reprojection errors for each point.
    """

    if track not in reconstruction['points']:
        return None, None

    shot1, camera1 = shot_camera(im1, reconstruction)
    shot2, camera2 = shot_camera(im2, reconstruction)
    point = reconstruction['points'][track]

    if distort:
        xr1 = reconstruct.reproject(camera1, shot1, point)
        xr2 = reconstruct.reproject(camera2, shot2, point)

        x1o = x1
        x2o = x2
    else:
        cc1 = reconstruct.camera_coordinates(camera1, shot1, point['coordinates'])
        cc2 = reconstruct.camera_coordinates(camera2, shot2, point['coordinates'])

        xr1 = camera1['focal'] * cc1[:2] / cc1[2]
        xr2 = camera2['focal'] * cc2[:2] / cc2[2]

        x1o = np.squeeze(multiview.undistort_points(camera1, np.reshape(x1, (2, 1))))
        x2o = np.squeeze(multiview.undistort_points(camera2, np.reshape(x2, (2, 1))))

    re1 = np.linalg.norm(xr1 - x1o)
    re2 = np.linalg.norm(xr2 - x2o)

    plot_points(subplot, im1_array, im2_array, np.resize(xr1, (1, 2)), np.resize(xr2, (1, 2)), '+w', '+w')

    return re1, re2


def plot_track_epipolar_geos(track, data, images=[], undistort=False, save_figs=False, single_column=False):
    """ Plots the epipolar geometry for image pairs connected to the track.

    :param track: The track name.
    :param data: Data set.
    :param images: If len(images) ==1: Only image pairs including the image will be plotted.
                   If len(images) == 2: Only the single image pair of the two images will be plotted.
    :param undistort: Boolean specifying if images and plotted points should be undistorted.
    :param save_figs: Boolean specifying if images should be saved to file instead of shown.
    :param single_column: Boolean specifying if subplots should be placed in a single column.
    """

    graph = data.load_tracks_graph()

    if track not in graph:
        print 'Track {0} does not exist in the tracks graph.'.format(track)
        return

    track_ims = graph[track]
    reconstruction, rec_ims = find_reconstruction([im for im in track_ims], data)
    if reconstruction is None:
        print 'No reconstruction for the track {0} contains any of the track images.'.format(track)
        return

    for im in images:
        if not im in rec_ims:
            print 'Track {0} is not connected to image {1} in the reconstruction.'.format(track, im)
            return

    rec_ims = sorted(rec_ims)
    if len(images) == 1:
        comb = [(images[0], im) for im in rec_ims if im != images[0]]
    elif len(images) == 2:
        comb = [(images[0], images[1])]
    else:
        comb = list(itertools.combinations(rec_ims, 2))

    n = len(comb)

    # Preload images to avoid loading them multiple times.
    im_arrays = {}
    for rec_im in rec_ims:
        rec_im_array = data.image_as_array(rec_im)
        if undistort:
            camera = shot_camera(rec_im, reconstruction)[1]
            rec_im_array = undistort_image(rec_im_array, camera)

        im_arrays[rec_im] = {}
        im_arrays[rec_im]['im'] = rec_im_array
        im_arrays[rec_im]['cam'] = shot_camera(rec_im, reconstruction)[1]

    point, res = reconstruction_point(track, reconstruction, graph, data.config.get('triangulation_min_ray_angle', 2.0))

    for chunk_index, chunk in enumerate(list(chunks(comb, 4))):
        chunk_size = len(chunk)
        rows = chunk_size if single_column else (2 if chunk_size > 1 else 1)
        cols = 1 if single_column else (2 if chunk_size > 2 else 1)

        epi_type = ('line' if undistort else 'curve')
        title = 'Epipolar ' + epi_type + 's on ' + ('un' if undistort else '') + \
                'distorted images for track {0} ({1}): ' + res
        fig = pl.figure(figsize=(12 * cols, 6 * rows - rows / 3 if rows < 4 else 21))
        fig.suptitle(title.format(track, data.feature_type().upper()), fontsize=14, fontweight='bold')

        for index, ims in enumerate(chunk):
            im1 = ims[0]
            im2 = ims[1]

            print 'Plotting epipolar geo for {0} - {1} ({2} / {3})'.format(im1, im2, chunk_index * 4 + index + 1, n)

            im1_array = im_arrays[im1]['im']
            im2_array = im_arrays[im2]['im']

            h1, w1, c = im1_array.shape
            h2, w2, c = im2_array.shape

            subplot = create_subplot(fig, rows, cols, index + 1, '', w1+w2, h1)
            show_images(subplot, im1_array, im2_array)

            x1 = np.array(track_ims[im1]['feature'])
            x2 = np.array(track_ims[im2]['feature'])

            d1, d2 = plot_epipolar_geo(subplot, im1, im2, im1_array, im2_array, x1, x2, reconstruction, not undistort)
            re1, re2 = plot_reprojections(
                subplot, im1, im2, im1_array, im2_array, x1, x2, track, reconstruction, not undistort)

            t1 = '{0}: Distortion: (k1: {1:.2g}, k2: {2:.2g}). ' + \
                 'Pixels to epipolar ' + epi_type + ': {3:.1f} ({4:.2g}). '
            t2 = 'Reprojection error: {0:.1f} ({1:.2g}).'

            c1 = im_arrays[im1]['cam']
            c2 = im_arrays[im2]['cam']

            s1 = np.max([h1, w1])
            s2 = np.max([h2, w2])

            t = t1.format(im1, float(c1['k1']), float(c1['k2']), s1 * d1, d1) + \
                (t2.format(s1 * re1, re1) if re1 is not None else '') + '\n' + \
                t1.format(im2, float(c2['k1']), float(c2['k2']), s2 * d2, d2) + \
                (t2.format(s2 * re2, re2) if re2 is not None else '')

            subplot.text(0.5, 1.04, t, horizontalalignment='center', fontsize=12, transform=subplot.transAxes)

        fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.93 if save_figs else 0.91,
                            wspace=0.04, hspace=0.14)

        if save_figs:
            path = data.data_path + '/plot_track'
            io.mkdir_p(path)
            fig.savefig(
                path + '/' + 'track_{0}_{1}_epipolar_{2}_{3}.jpg'
                .format(track, data.feature_type(), 'undist' if undistort else 'dist', chunk_index + 1),
                dpi=100)
            pl.close()
        else:
            pl.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot track epipolar geometry and rays in 3D')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('track',
                        help='name of the track to plot (integer)', type=int)
    parser.add_argument('--image1',
                        help='name of image for whose combinations should be plotted for the track')
    parser.add_argument('--image2',
                        help='name of image to plot in combination with image1 (only used if image1 is specified)')
    parser.add_argument('--undistort',
                        help='undistort images and plot epipolar lines instead of epipolar curves',
                        action='store_true')
    parser.add_argument('--save_figs',
                        help='save epipolar line figures instead of showing them',
                        action='store_true')
    parser.add_argument('--single_col',
                        help='show subplots in a single column in figures',
                        action='store_true')

    args = parser.parse_args()
    ds = dataset.DataSet(args.dataset)
    tr = str(args.track)

    arg_ims = []
    if args.image1:
        arg_ims.append(args.image1)
        if args.image2:
            arg_ims.append(args.image2)

    plot_track_epipolar_geos(tr, ds, arg_ims, args.undistort, args.save_figs, args.single_col)
    plot_track_rays(tr, ds)