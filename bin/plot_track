#!/usr/bin/env python

import os.path, sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import argparse
import matplotlib as mpl
import matplotlib.pyplot as pl
import matplotlib.tri as mtri
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import itertools
import cv2

from opensfm import dataset
from opensfm import features
from opensfm import io
from opensfm import multiview
import opensfm.reconstruction as reconstruct


def show_images(plot, im1, im2):
    """ Shows the images in the supplied subplot. """
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    image = np.zeros((max(h1, h2), w1+w2, 3), dtype=im1.dtype)
    image[0:h1, 0:w1, :] = im1
    image[0:h2, w1:(w1+w2), :] = im2
    plot.imshow(image)


def plot_points(plot, im1, im2, p1, p2, point_format1='ob', point_format2='ob'):
    """ Plots the points in the supplied subplot. """
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    p2d = features.denormalized_image_coordinates(p2, w2, h2)

    plot.plot(p1d[:, 0], p1d[:, 1], point_format1)
    plot.plot(p2d[:, 0] + w1, p2d[:, 1], point_format2)


def create_subplot(figure, rows, columns, index, title, width, height, font_size=12):
    """ Creates a subplot with the supplied width. """
    subplot = figure.add_subplot(rows, columns, index)
    subplot.axis('off')
    pl.xlim(0, width)
    pl.ylim(height, 0)
    subplot.text(0.5, 1.04,
                 title,
                 horizontalalignment='center',
                 fontsize=font_size,
                 transform=subplot.transAxes)

    return subplot


def plot_point(plot, x, color, size=11):
    """ Plots a point.

    :param plot: The plot.
    :param x: The point.
    :param color: The color of the point.
    :param size: The size of the point.
    """

    plot.scatter(x[0], x[1], x[2], c=color, s=size)


def plot_ray(plot, p, d, l, color, name=None):
    """ Plots a ray from a point of length l in direction d.

    :param plot: The plot.
    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the ray.
    :param name: The name of the ray.
    :param color: The color of the ray.
    """

    points = line_points(p, d, l)
    plot.plot(points[0], points[1], points[2], label=name, c=color)


def plot_plane(plot, c):
    """ Plots a plane based on the defined corners.

    :param plot: The plot.
    :param c: The corners.
    """

    triangles = mtri.Triangulation(c[0, :], c[1, :])
    plot.plot_trisurf(triangles, c[2, :], color='b', alpha=0.2, linewidth=0.1)


def line_points(p, d, l):
    """ Calculates the start and end point for a line.

    :param p: The starting point.
    :param d: The direction.
    :param l: The length of the line.
    :return: Array of coordinates for the line.
    """

    return np.add(
        np.multiply(np.resize(np.linspace(0, l, 2), (1, 2)), np.resize(d, (d.shape[0], 1))),
        np.resize(p, (p.shape[0], 1)))


def image_plane_corners(oc, KR_inv, width, height):
    """ Calculates corners of an image plane.

    :param oc: The optical center.
    :param KR_inv: The inverse of the 3 x 3 matrix of the first three columns of the camera matrix P.
    :param width: The width of the camera.
    :param height: The height of the camera.
    :return: Array of coordinates for the coordinates.
    """
    max_dim = np.max((width, height))
    dx = width / (2.0 * max_dim)
    dy = height / (2.0 * max_dim)

    corners = np.dot(KR_inv, np.array([[-dx,  dx,  dx, -dx],
                                       [-dy, -dy,  dy,  dy],
                                       [ 1,   1,   1,   1]]))

    return np.add(np.resize(oc, (3, 1)), corners)


def epipole(Pi, Cj):
    """ Calculates the epipole for another camera.

    :param Pi: The camera matrix for the first camera.
    :param Cj: The camera center for the second camera.
    :return: The epipole of the second camera for the first.
    """
    ei = np.dot(Pi, Cj)

    return ei / ei[2]


def fundamental_matrix(P1, P2, C1):
    """ Calculates the fundamental matrix for two cameras.

    :param P1: The camera matrix for the first camera.
    :param P2: The camera matrix for the second camera.
    :param C1: The camera center for the first camera in homogeneous coordinates.
    :return: The fundamental matrix for the cameras.
    """
    P1_pinv = np.linalg.pinv(P1)

    e2 = epipole(P2, C1)
    e2_cross = np.array([[ 0,     -e2[2],   e2[1]],
                         [ e2[2],  0,      -e2[0]],
                         [-e2[1],  e2[0],   0]])

    F = np.dot(e2_cross, np.dot(P2, P1_pinv))

    return F


def epipolar_line(F, x):
    """ Calculates the epipolar line for a point in the other image.

    :param F: Fundamental matrix.
    :param x: Point in other image in homogeneous coordinates.
    :return: The epipolar line for the point in the other image.
    """
    return np.dot(F, x)


def line_equation_points(l, xy_min=-1., xy_max=1., n=400):
    """ Calculates points on a line.

    :param l: Line equation
    :param xy_min: Smallest value.
    :param xy_max: Largest value.
    :param n: Number of points.
    :return: An array of points that lie on the line.
    """

    # Create linear space points along axis with most slope with respect to the other.
    if abs(l[1]) < 1.e-4 or np.abs(l[0] / l[1]) > 1:
        y = np.linspace(xy_min, xy_max, n)
        x = (-l[1] * y - l[2]) / l[0]
    else:
        x = np.linspace(xy_min, xy_max, n)
        y = (-l[0] * x - l[2]) / l[1]

    x = np.resize(x, (x.shape[0], 1))
    y = np.resize(y, (y.shape[0], 1))

    return np.hstack((x, y))


def reconstruction_point(track, reconstruction, graph, min_ray_angle):
    """ Retrieves the 3D point from a reconstruction. If the point for the track does not exist
        in the reconstruction an attempt is made to triangulate the track.

    :param track: A track.
    :param reconstruction: A reconstruction.
    :param graph: A track graph.
    :param min_ray_angle: Minimum ray angle between track rays for a track to be triangulated.
    :return:
    """
    point = None

    if track in reconstruction['points']:
        point = reconstruction['points'][track]['coordinates']
    else:
        reconstruct.triangulate_track(track, graph, reconstruction, {}, {}, {}, 1, min_ray_angle)
        if track in reconstruction['points']:
            point = reconstruction['points'][track]['coordinates']

    return point


def find_reconstruction(images, data):
    """ Finds the reconstruction containing the most images.

    :param images: The image names.
    :param data: The data set
    :return: The reconstruction containing the most images.
    """

    reconstructions = data.load_reconstruction()
    reconstruction = None
    rec_images = []

    contained = 0
    for r in reconstructions:
        count = 0
        ims = []
        for im in images:
            if im in r['shots']:
                ims.append(im)
                count += 1

        if count > contained:
            contained = count
            reconstruction = r
            rec_images = ims
            break

    return reconstruction, rec_images


def distort_points(camera, x):
    """ Distorts a points using the distortion coefficients of the camera.
    :param camera: The camera.
    :param x: The points.
    :return: Array of distorted points.
    """
    result = []

    for point in x:
        x_distort, y_distort = reconstruct.distort(camera, point[0], point[1])
        result.append(np.array([x_distort, y_distort]))

    return np.array(result)


def undistort_image(im_array, camera):
    """ Undistorts an image using the camera properties.
    :param im_array: The image array.
    :param camera: The camera.
    :return: An image with the undistorted pixels.
    """
    d = np.array([camera['k1'], camera['k2'], 0., 0., 0.])
    f = camera['focal']
    w = camera['width']
    h = camera['height']

    s = np.max([w, h])

    K = np.array([[s*f, 0,   w/2],
                  [0,   s*f, h/2],
                  [0,   0,   1]])

    undistorted_im_array = cv2.undistort(im_array, K, d)

    return undistorted_im_array


def shot_camera(im, reconstruction):
    """ Retrieves the shot and camera for an image in a reconstruction.
    :param im: The image name.
    :param reconstruction: The reconstruction.
    :return: The shot and the camera for the image.
    """
    shot = reconstruction['shots'][im]
    camera = reconstruction['cameras'][shot['camera']]

    return shot, camera


def chunks(l, n):
    """ Separates a list in smaller chunks of items.

    :param l: List
    :param n: Number of items in each chunk
    :return: Chunks of the specified size.
    """
    for i in xrange(0, len(l), n):
        yield l[i:i+n]


def plot_image_feature(plot, im, x, reconstruction, point, fraction):
    xh = multiview.homogeneous(x)

    shot, camera = shot_camera(im, reconstruction)
    P = reconstruct.projection_matrix(camera, shot)
    KR_inv = np.linalg.inv(P[:, :3])

    vs = np.dot(KR_inv, xh)

    oc = reconstruct.optical_center(shot)
    vd = reconstruct.viewing_direction(shot)
    cs = image_plane_corners(oc, KR_inv, camera['width'], camera['height'])

    # Plot image plane from image plane corners
    plot_plane(plot, cs)

    # Plot optical center
    plot_point(plot, oc, 'yellow')

    # Plot principal point
    principal_ray_dir = vd / np.linalg.norm(vd)
    plot_point(plot, oc + principal_ray_dir, (1., .6, .0))

    # Plot track image projection
    projection = np.dot(vs, principal_ray_dir)
    im_plane_intersect = vs / projection
    plot_point(plot, oc + im_plane_intersect, 'cyan')

    ray_length = np.linalg.norm(point - oc) + 5 if point is not None else 5

    # Plot track ray
    plot_ray(plot, oc, vs, ray_length, (.0, .9 * fraction, .2 + .7 * fraction), '{0} track ray'.format(im))

    # Plot principal ray
    plot_ray(plot, oc, vd, ray_length, 'r')

    return oc


def plot_track_ray(track, data):
    graph = data.load_tracks_graph()

    if track not in graph:
        print 'Track {0} does not exist in the tracks graph.'.format(track)
        return

    images = graph[track]
    reconstruction, rec_images = find_reconstruction([im for im in images], data)
    if reconstruction is None:
        print 'No reconstruction for the track {0} contains any of the track images.'.format(track)
        return

    point = reconstruction_point(track, reconstruction, graph, data.config.get('triangulation_min_ray_angle', 2.0))

    fig = pl.figure(figsize=(10, 10))
    plot = fig.gca(projection='3d', aspect='equal', xlabel='X-axis', ylabel='Y-axis', zlabel='Z-axis')

    points = []
    for index, im in enumerate(rec_images):
        fraction = 1 if len(rec_images) == 1 else float(index) / (len(rec_images) - 1)
        oc = plot_image_feature(plot, im, np.array(images[im]['feature']), reconstruction, point, fraction)
        points.append(oc)

    if point is not None:
        plot_point(plot, point, 'k', 12)
        points.append(point)

    # Make sure the plot is metric.
    coord_max = np.max(points, axis=0)
    coord_min = np.min(points, axis=0)
    coord_diff = np.subtract(coord_max, coord_min)
    k = (np.max(coord_diff) - coord_diff) / 2
    min_lim = coord_min - k - 5
    max_lim = coord_max + k + 5

    plot.set_xlim(min_lim[0], max_lim[0])
    plot.set_ylim(min_lim[1], max_lim[1])
    plot.set_zlim(min_lim[2], max_lim[2])

    fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.99, wspace=0, hspace=0)

    mpl.rcParams['legend.fontsize'] = 10
    plot.legend()

    pl.show()


def plot_epipolar_geo(subplot, im1, im2, im1_array, im2_array, x1, x2, reconstruction, distort=True):
    shot1, camera1 = shot_camera(im1, reconstruction)
    shot2, camera2 = shot_camera(im2, reconstruction)

    P1 = reconstruct.projection_matrix(camera1, shot1)
    P2 = reconstruct.projection_matrix(camera2, shot2)

    C1 = multiview.homogeneous(reconstruct.optical_center(shot1))
    C2 = multiview.homogeneous(reconstruct.optical_center(shot2))

    F = fundamental_matrix(P1, P2, C1)

    # Undistort points before calculating epipolar line.
    x1u = np.squeeze(multiview.undistort_points(camera1, np.reshape(x1, (2, 1))))
    x2u = np.squeeze(multiview.undistort_points(camera2, np.reshape(x2, (2, 1))))

    l1 = epipolar_line(F.T, multiview.homogeneous(x2u))
    l2 = epipolar_line(F, multiview.homogeneous(x1u))

    lp1 = line_equation_points(l1)
    lp2 = line_equation_points(l2)

    e1 = epipole(P1, C2)
    e2 = epipole(P2, C1)

    if distort:
        # Distort epipolar line points to transform them to epipolar curve points.
        lp1 = distort_points(camera1, lp1)
        lp2 = distort_points(camera2, lp2)

        # Distort epipole.
        e1 = np.array(reconstruct.distort(camera1, e1[0], e1[1]))
        e2 = np.array(reconstruct.distort(camera2, e2[0], e2[1]))

        # Distort feature points
        x1u = x1
        x2u = x2

    lp1 = lp1[lp1[:, 0] < .5]
    lp2= lp2[lp2[:, 0] > -.5]

    plot_points(subplot, im1_array, im2_array, lp1, lp2, 'r', 'r')
    plot_points(subplot, im1_array, im2_array, np.resize(e1[:2], (1, 2)), np.resize(e2[:2], (1, 2)), 'or', 'or')
    plot_points(subplot, im1_array, im2_array, np.resize(x1u, (1, 2)), np.resize(x2u, (1, 2)), 'oc', 'oc')


def plot_epipolar_lines(track, data, images=[], undistort=False, save_figs=False, single_column=False):
    graph = data.load_tracks_graph()

    if track not in graph:
        print 'Track {0} does not exist in the tracks graph.'.format(track)
        return

    track_ims = graph[track]
    reconstruction, rec_ims = find_reconstruction([im for im in track_ims], data)
    if reconstruction is None:
        print 'No reconstruction for the track {0} contains any of the track images.'.format(track)
        return

    for im in images:
        if not im in rec_ims:
            print 'Track {0} is not connected to image {1} in the reconstruction.'.format(track, im)
            return

    rec_ims = sorted(rec_ims)
    if len(images) == 1:
        comb = [(images[0], im) for im in rec_ims if im != images[0]]
    elif len(images) == 2:
        comb = [(images[0], images[1])]
    else:
        comb = list(itertools.combinations(rec_ims, 2))

    n = len(comb)

    # Preload images to avoid loading them multiple times.
    im_arrays = {}
    for rec_im in rec_ims:
        rec_im_array = data.image_as_array(rec_im)
        if undistort:
            camera = shot_camera(rec_im, reconstruction)[1]
            rec_im_array = undistort_image(rec_im_array, camera)
        im_arrays[rec_im] = rec_im_array

    for chunk_index, chunk in enumerate(list(chunks(comb, 4))):
        chunk_size = len(chunk)
        rows = chunk_size if single_column else (2 if chunk_size > 1 else 1)
        cols = 1 if single_column else (2 if chunk_size > 2 else 1)

        title = 'Epipolar lines on undistorted images for track {0} ({1})' if undistort else \
                'Epipolar curves on distorted images for track {0} ({1})'
        fig = pl.figure(figsize=(12 * cols, 6 * rows - rows / 3 if rows < 4 else 21))
        fig.suptitle(title.format(track, data.feature_type().upper()),
                     fontsize=14, fontweight='bold')

        for index, ims in enumerate(chunk):
            im1 = ims[0]
            im2 = ims[1]

            print 'Plotting epipolar geo for {0} - {1} ({2} / {3})'.format(im1, im2, chunk_index * 4 + index + 1, n)

            im1_array = im_arrays[im1]
            im2_array = im_arrays[im2]

            h1, w1, c = im1_array.shape
            h2, w2, c = im2_array.shape

            subplot = create_subplot(fig, rows, cols, index + 1, '{0} - {1}'.format(im1, im2), w1+w2, h1)
            show_images(subplot, im1_array, im2_array)

            x1 = np.array(track_ims[im1]['feature'])
            x2 = np.array(track_ims[im2]['feature'])

            plot_epipolar_geo(subplot, im1, im2, im1_array, im2_array, x1, x2, reconstruction, not undistort)

        fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.93 if save_figs else 0.91,
                            wspace=0.04, hspace=0.14)

        if save_figs:
            path = data.data_path + '/plot_track'
            io.mkdir_p(path)
            fig.savefig(
                path + '/' + 'track_{0}_{1}_epipolar_{2}_{3}.jpg'
                .format(track, data.feature_type(), 'undist' if undistort else 'dist', chunk_index + 1),
                dpi=100)
            pl.close()
        else:
            pl.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot track epipolar geometry and rays in 3D')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('track',
                        help='name of the track to plot (integer)', type=int)
    parser.add_argument('--image1',
                        help='name of image for whose combinations should be plotted for the track')
    parser.add_argument('--image2',
                        help='name of image to plot in combination with image1 (only used if image1 is specified)')
    parser.add_argument('--undistort',
                        help='undistort images and plot epipolar lines instead of epipolar curves',
                        action='store_true')
    parser.add_argument('--save_figs',
                        help='save epipolar line figures instead of showing them',
                        action='store_true')
    parser.add_argument('--single_col',
                        help='show subplots in a single column in figures',
                        action='store_true')

    args = parser.parse_args()
    ds = dataset.DataSet(args.dataset)
    tr = str(args.track)

    arg_ims = []
    if args.image1:
        arg_ims.append(args.image1)
        if args.image2:
            arg_ims.append(args.image2)

    plot_epipolar_lines(tr, ds, arg_ims, args.undistort, args.save_figs, args.single_col)
    plot_track_ray(tr, ds)