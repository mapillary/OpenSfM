#!/usr/bin/env python
import os.path, sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import numpy as np
import argparse
import json
from labmv import transformations as tf
from labmv import dataset
from labmv import features
from labmv import multiview
import networkx as nx
from networkx.algorithms import bipartite


def best_initial_pair(graph):
    # Get the image connectivity graph.
    track_nodes, image_nodes = bipartite.sets(graph)
    image_graph = bipartite.weighted_projected_graph(graph, image_nodes)
    best_pair = None
    best_weight = 0
    for im1, im2, d in image_graph.edges(data=True):
        if d['weight'] > best_weight:
            best_weight = d['weight']
            best_pair = (im1, im2)
    return best_pair


def bootstrap_reconstruction(data, graph):
    im1, im2 = best_initial_pair(graph)
#    im1, im2 = '2013_10_30_09_04_56_100.jpg', '2013_10_30_09_04_54_112.jpg'
    print 'Matching image', im1, 'with image', im2
    d1 = data.exif_data(im1)
    d2 = data.exif_data(im2)
    tracks, p1, p2 = dataset.common_tracks(graph, im1, im2)

    print 'Number of common tracks', len(tracks)
    R, t, inliers, Xs = features.two_view_reconstruction(p1, p2, d1, d2)
    print 'Number of inliers', len(inliers)

    reconstruction = {
        "cameras": {
            "main_camera": {
                "width": d1["width"],
                "height": d1["height"],
                "focal": d1["focal_ratio"] * d1["width"],
            },
        },

        "shots" : {
            im1: {
                "camera": "main_camera",
                "rotation": [0, 0, 0],
                "translation": [0, 0, 0],
            },
            im2: {
                "camera": "main_camera",
                "rotation": list(angleaxis(R)),
                "translation": list(t),
            },
        },

        "points" : {
        },
    }
    triangulate_shot_features(graph, reconstruction, im1)
    return reconstruction


def reconstructed_points_for_images(graph, reconstruction):
    tracks, images = bipartite.sets(graph)
    res = []
    for image in images:
        if image not in reconstruction['shots']:
            common_tracks = 0
            for track in graph[image]:
                if track in reconstruction['points']:
                    common_tracks += 1
            res.append((image, common_tracks))
    return sorted(res, key=lambda x: -x[1])


def rotation_matrix(angleaxis):
    angle = np.linalg.norm(angleaxis)
    if angle < 1e-8:
        return np.eye(3)
    return tf.rotation_matrix(angle, angleaxis)[:-1, :-1]


def rotate(angleaxis, point):
    R = rotation_matrix(angleaxis)
    return R.dot(np.array(point))


def angleaxis(R):
    '''Compute angle-axis representation from a rotation matrix.
    '''
    T = np.identity(4)
    T[:3,:3] = R
    angle, direction, point = tf.rotation_from_matrix(T)
    return direction / np.linalg.norm(direction) * angle


def single_reprojection_error(camera, shot, point, observation):
    p = rotate(shot['rotation'], point['coordinates'])
    p += shot['translation']
    xp = p[0] / p[2]
    yp = p[1] / p[2]

    l1 = camera.get('k1', 0.0)
    l2 = camera.get('k2', 0.0)
    r2 = xp * xp + yp * yp;
    distortion = 1.0 + r2  * (l1 + l2  * r2)

    predicted_x = camera['focal'] * distortion * xp + camera['width'] / 2
    predicted_y = camera['focal'] * distortion * yp + camera['height'] / 2

    rx = predicted_x - observation[0]
    ry = predicted_y - observation[1]
    return np.sqrt(rx * rx + ry * ry)


def reprojection_error(graph, reconstruction):
    tracks, shots = bipartite.sets(graph)
    errors = []
    for shot_id in shots:
        if shot_id in reconstruction['shots']:
            for track_id in graph[shot_id]:
                if track_id in reconstruction['points']:
                    observation = graph[shot_id][track_id]['feature']
                    shot = reconstruction['shots'][shot_id]
                    camera = reconstruction['cameras'][shot['camera']]
                    point = reconstruction['points'][track_id]
                    errors.append(single_reprojection_error(camera, shot, point, observation))
    return np.mean(errors)


def resect(graph, reconstruction, shot_id, min_inliers=20):
    '''Add a shot to the reconstruction.
    '''
    xs = []
    Xs = []
    for track in graph[shot_id]:
        if track in reconstruction['points']:
            xs.append(graph[shot_id][track]['feature'])
            Xs.append(reconstruction['points'][track]['coordinates'])
    x = np.array(xs)
    X = np.array(Xs)
    K = K_from_camera(reconstruction['cameras']['main_camera'])
    kernel = multiview.ResectionP3PKernel(x, X, K)
    (R, t), inliers, error = multiview.ransac(kernel, 5)
    print 'Resection inliers:', len(inliers), '/', len(x)
    if len(inliers) >= min_inliers:
        reconstruction['shots'][shot_id] = {
            "camera": "main_camera",
            "rotation": list(angleaxis(R)),
            "translation": list(t),
        }
        return True
    else:
        return False

def K_from_camera(camera):
    f = camera['focal']
    w = camera['width']
    h = camera['height']
    return np.array([[f, 0, w / 2],
                     [0, f, h / 2],
                     [0, 0, 1]])

def Rt_from_shot(shot):
    Rt = np.empty((3, 4))
    Rt[:,:3] = rotation_matrix(shot['rotation'])
    Rt[:, 3] = shot['translation']
    return Rt

def projection_matrix(camera, shot):
    K = K_from_camera(camera)
    Rt = Rt_from_shot(shot)
    return np.dot(K, Rt)



def triangulate_shot_features(graph, reconstruction, shot_id):
    '''Reconstruct as many tracks seen in shot_id as possible.
    '''
    P_by_id = {}
    for track in graph[shot_id]:
        if track not in reconstruction['points']:
            Ps = []
            xs = []
            for shot in graph[track]:
                if shot in reconstruction['shots']:
                    if shot not in P_by_id:
                        s = reconstruction['shots'][shot]
                        c = reconstruction['cameras'][s['camera']]
                        P_by_id[shot] = projection_matrix(c, s)
                    Ps.append(P_by_id[shot])
                    xs.append(graph[track][shot]['feature'])
            if len(Ps) >= 2:
                X = multiview.triangulate(Ps, xs)
                error = 0
                Xh = multiview.homogeneous(X)
                for P, x in zip(Ps, xs):
                    xx, yy, zz = P.dot(Xh)
                    if zz <= 0:
                        error = 999999999.0
                    reprojected_x = np.array([xx / zz, yy / zz])
                    error = max(error, (reprojected_x - x).max())
                if error < 3:
                    reconstruction['points'][track] = {
                        "coordinates": list(X),
                    }



if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Compute reconstruction')
    parser.add_argument('dataset',
                        help='path to the dataset to be processed')
    args = parser.parse_args()

    data = dataset.DataSet(args.dataset)
    graph = data.tracks_graph()

    reconstruction = bootstrap_reconstruction(data, graph)
    #TODO(pau) resectionP3P fails on the 4's image of malmo_small: it gives a mirror solution.
    reconstruction = features.bundle(data.tracks_file(), reconstruction)

    i = 0
    while True:
        with open(data.reconstruction_file().replace('json', '%04d.json'%i), 'w') as fout:
            fout.write(json.dumps(reconstruction, indent=4))
            i += 1
        common_tracks = reconstructed_points_for_images(graph, reconstruction)
        if not common_tracks:
            break
        for image, num_tracks in common_tracks:
            print 'Adding {0} to the reconstruction'.format(image)
            print reconstruction['cameras']['main_camera']['focal']
            if resect(graph, reconstruction, image, min_inliers=15):
                print 'Resection succeded'
                reconstruction = features.bundle(data.tracks_file(), reconstruction)
                print 'BEFORE', reprojection_error(graph, reconstruction)
                triangulate_shot_features(graph, reconstruction, image)
                print 'AFTER', reprojection_error(graph, reconstruction)
                reconstruction = features.bundle(data.tracks_file(), reconstruction)
                break
            else:
                print 'Resection failed'
        else:
            print 'Some cameras could be resected'
            break

    with open(data.reconstruction_file(), 'w') as fout:
        fout.write(json.dumps(reconstruction, indent=4))





