#!/usr/bin/env python

import os.path, sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import argparse
import time
import json
import cv2
import numpy as np
import scipy.spatial.distance as dist
import networkx as nx

from opensfm import dataset

def load_reconstructions(data):
    with open(data.reconstruction_file()) as fin:
        return json.load(fin)

def optical_center(shot):
    R = cv2.Rodrigues(np.array(shot['rotation'], dtype=float))[0]
    t = shot['translation']
    return -R.T.dot(t)

def viewing_direction(shot):
    R = cv2.Rodrigues(np.array(shot['rotation'], dtype=float))[0]
    t = np.array([0, 0, 1])
    return R.T.dot(t)

def vector2_angle(x1, y1, x2, y2):
    angle = np.arctan2(y1, x1) - np.arctan2(y2, x2)
    if angle > np.pi:
        return angle - 2 * np.pi
    elif angle < -np.pi:
        return angle + 2 * np.pi
    else:
        return angle

def angle_diff(v, angle):
    diff = np.abs(v - angle)

    # Make sure the angle difference is less than Pi
    diff = np.min(np.vstack((diff, 2*np.pi - diff)), 0)
    return diff

def create_optical_center_graph(reconstructions):

    optical_centers = []
    viewing_directions = []
    shot_ids = []

    for reconstruction in reconstructions:
        for shot_id in sorted(reconstruction['shots'].keys()):
            shot = reconstruction['shots'][shot_id]
            optical_centers.append(optical_center(shot))
            viewing_directions.append(viewing_direction(shot))
            shot_ids.append(shot_id)

    optical_centers = np.vstack(optical_centers)
    viewing_directions = np.vstack(viewing_directions)

    D = dist.squareform(dist.pdist(optical_centers))

    min_distance = 0.01
    max_distance = 20
    step_threshold = 0.25
    turn_threshold = 0.7

    direction = 'direction'
    threshold = 'threshold'

    step_directions = {
        'step_forward': {direction: 0, threshold: step_threshold},
        'step_backward': {direction: np.pi, threshold: 2*step_threshold},
        'step_left': {direction: -np.pi / 2, threshold: 2*step_threshold},
        'step_right': {direction: np.pi / 2, threshold: 2*step_threshold}
    }

    turn_directions = {
        'turn_left': {direction: -np.pi / 2, threshold: turn_threshold},
        'turn_right': {direction: np.pi / 2, threshold: turn_threshold},
        'turn_u': {direction: np.pi, threshold: turn_threshold}
    }

    graph = nx.DiGraph()

    for i in range(0, D.shape[0]):

        distances = D[i, :]
        oc = optical_centers[i]
        vd = viewing_directions[i]

        # Order potential optical centers according to shortest distance
        potential = np.where((min_distance < distances) & (distances < max_distance))[0]
        ordered_indices = potential[np.argsort(distances[potential])]
        motions = optical_centers[ordered_indices] - oc
        viewings = viewing_directions[ordered_indices]

        motion_angles = np.array([vector2_angle(vd[0], vd[1], motion[0], motion[1]) for motion in motions], float)
        viewing_angle_differences = np.array([vector2_angle(vd[0], vd[1], viewing[0], viewing[1]) for viewing in viewings], float)

        for key in step_directions:
            step_direction = step_directions[key]
            ma_diff = angle_diff(motion_angles, step_direction[direction])
            step_indices = np.where((ma_diff < step_direction[threshold]) & (np.abs(viewing_angle_differences) < step_direction[threshold]))[0]

            if len(step_indices) > 0:
                step_index = ordered_indices[step_indices[0]]
                graph.add_edge(shot_ids[i], shot_ids[step_index], weight=distances[step_index], direction=key)

        for key in turn_directions:
            turn_direction = turn_directions[key]
            va_diff = angle_diff(viewing_angle_differences, turn_direction[direction])
            turn_indices = np.where((va_diff < turn_direction[threshold]))[0]

            if len(turn_indices) > 0:
                turn_index = ordered_indices[turn_indices[0]]
                graph.add_edge(shot_ids[i], shot_ids[turn_index], weight=distances[turn_index], direction=key)

    return graph

if __name__ == "__main__":
    start = time.time()
    parser = argparse.ArgumentParser(description='Compute directed graph from reconstruction')
    parser.add_argument('dataset',
                        help='path to the dataset to be processed')
    args = parser.parse_args()

    data = dataset.DataSet(args.dataset)
    recs = load_reconstructions(data)
    directed_graphs = []

    rec_graph = create_optical_center_graph(recs)
    directed_graph = {
        'edges': {},
        'nodes': list(rec_graph.node)
    }

    for edge in rec_graph.edge:
        directed_graph['edges'][edge] = rec_graph.edge[edge]

    directed_graphs.append(directed_graph)

    with open(data.directed_graph(), 'w') as fout:
        fout.write(json.dumps(directed_graphs))

    end = time.time()
    with open(data.profile_log(), 'a') as fout:
        fout.write('Directed graphs: {0}\n'.format(end - start))


